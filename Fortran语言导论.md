# 第一章 概要
**目的**

本章的目的是为本书的组织提供背景。

## 1.1 介绍
该书旨在提供有关Fortran编程语言的合理工作子集。 选择的子集应使您能够解决很多经常发生的问题。

这本书是为三位读者写的：

* 几乎没有编程背景的完整初学者
* 经验丰富的Fortran程序员，他想更新自己的技能并转向该语言的现代版本
* 熟悉另一种语言的程序员希望了解现代Fortran提供的功能

第2章和第3章介绍了解决问题以及编程语言的历史和发展。第2章对于初学者来说至关重要，因为在本书的其余部分都使用并扩展了其中引入的概念。第3章应在某些地方阅读 点，但一开始可以省略。 编程语言不断发展，并且从长远来看，对Fortran的来源和去向的一些了解将是有价值的。

* 第2章深入探讨问题解决，涵盖了我们定义问题的方式，算法的作用，自上而下和自下而上方法的使用以及对正式系统进行分析和设计的要求更复杂的问题。
* 第3章介绍了编程语言的历史和发展。 这一点非常重要，因为Fortran从1950年代中期的起源就已经有了很大的发展，直到1966年的第一个标准，Fortran 77标准，Fortran 90标准，Fortran 95标准，TR 15580和TR 15581，Fortran 2003，Fortran 2008 到Fortran2018。它有助于将Fortran的许多当前和建议功能纳入背景。 涵盖的语言包括Cobol，Algol，Lisp，Snobol，PL / 1，Algol 68，Simula，Pascal，APL，Basic，C，Ada，Modula，Modula 2，Logo，Prolog，SQL，ICON，Oberon，Oberon 2，Smalltalk， C ++，C＃，Java和Python。

第4-8章介绍了Fortran中提供的主要功能，它们首先用于数字编程，其次用于通用编程。 每章都有一系列问题。 尝试并完成合理范围的问题非常重要，因为没有实践就不可能学习任何语言。

* 第4章通过一些简单的Fortran示例介绍编程。对于具有编程知识的人，本章可以很快覆盖。
* 第5章深入探讨算术，涵盖各种数值数据类型，表达式和标量变量的分配。还全面介绍了Fortran提供的功能，以帮助编写可在不同硬件平台上运行的程序。
* 第6章介绍了数组和do循环。本章从一些应该熟悉的表格结构示例开始。然后检查一下在编程语言中需要哪些概念来支持对表格数据的操作。
* 第7章介绍了第一章中介绍的思想。 6，并将它们扩展到更高维度的数组，维度属性的其他形式和do循环的相应形式，以及使用循环来控制表格信息的重复和操作，而无需使用阵列。
* 第8章介绍了用于操纵整个数组和数组节的更多工具，我们可以使用构造函数初始化数组，更正式地介绍了我们需要能够准确描述和理解数组的概念，最后介绍了Fortran允许我们使用数组的方式与控制矩阵的数学规则之间的差异。

第9、10和11章介绍了Fortran中的输入和输出（I / O）和文件处理。 对I / O的理解对于开发所谓的生产非交互式程序是必要的。 这些本质上是完全开发的程序，可重复使用各种数据输入和结果。

* 第9章着眼于结果的输出，以及如何生成比自由格式输出更易理解和易于阅读的内容，以及如何将结果写入文件而不是屏幕。
* 第10章扩展了第1章中介绍的思想。 涵盖了数据输入或将数据读取到程序中，并且还考虑了文件I / O。
* 第11章概述了Chaps中引入的输入和输出概念，并通过引入read，write，open和close语句的其他功能对其进行了扩展。

第12章介绍了Fortran中可用的第一个构建块，用于构建用于解决较大，更复杂问题的程序。 它介绍了Fortran中可用的功能，所谓的内在功能和过程（其中有100多种），并介绍了如何定义和使用自己的功能。

必须了解该语言提供的功能以及何时需要编写自己的语言。

第13章更正式地介绍了控制结构的概念及其在结构化编程中的作用。 在前面的章节中介绍了Fortran中可用的一些控制结构，但是这里总结了已经涵盖的控制结构以及一些新的结构，这些结构完善了我们对最小工作集的覆盖范围。

第14-16章完整介绍了Fortran中用于数据键入的内在功能。

* 第14章介绍了Fortran中的字符数据类型。 再次介绍了I / O，并提供了可用的运算符-实际上只有一个。
* 第15章介绍了Fortran中的最后一个数值数据类型，即复杂数据类型。此数据类型对于解决一小类数学和工程问题至关重要。
* 第16章介绍逻辑数据类型。 此处介绍的材料在很大程度上提高了我们在Fortran中使用和构造逻辑表达式的方式的功能和复杂性。 在控制结构中逻辑表达式的构造和使用中，这被证明是无价的。

第17章通过少量示例介绍了派生类型或用户定义的类型。

第18章介绍了Fortran中提供的动态数据结构功能以及指针。本章介绍了指针的基本语法。在本书的后续章节中，将在一系列示例中使用它们。

接下来的两章介绍了Fortran的第二个主要构建块—子例程。第19章简要介绍了子例程定义和使用的一些基本概念，第20章则扩展了这些思想。

第21章介绍了现代Fortran的主要主要功能之一-模块。可以将Fortran模块视为等同于C ++，Java和C＃中的类。本章通过一些简单示例介绍了基本语法。

第22章介绍了Fortran中的简单数据结构，因为我们现在更深入地介绍了模块。

第23章介绍算法和大O表示法。

第24章简要介绍了运算符重载，它在Fortran 90中首次引入。

第25章介绍通用编程。

第26章提供了一些数学示例。

第27章介绍了参数化派生类型。

第28章介绍了Fortran中的面向对象编程。

第29章是有关面向对象编程的第二章

第30–34章介绍了Fortran中的并行编程，涵盖了MPI，OpenMP和Coarray Fortran。

第35章介绍C语言的互操作性。

第36章介绍了Fortran中的IEEE算术支持。

第37章介绍Fortran中的派生类型I / O

第38章介绍了一些排序和搜索的示例

第39章着眼于处理计算中的缺失数据

第40章讨论从Fortran 77到更现代的Fortran的转换。

第41章介绍使用图形库进行绘图

第42章提供了Fortran中的抽象接口和过程指针的示例

有些章节带有参考书目。这些通常具有指示和指导以供进一步阅读。所提供的范围不能孤立地看到。所引入的概念只是出于简要目的，在必要时必须寻求更全面的介绍。除非另有说明，否则本书中对标准的引用均指当前的Fortran 2018版本。有几个附录：

* 附录A-这是一个词汇表，涵盖了Fortran提供的新概念以及一系列计算术语和思想。
* 附录B是有关属性声明和规范的参考附录
* 附录C-提供标准之间兼容性的详细信息
* 附录D-包含Fortran中一些更常用的内在过程的列表，并包括对每个过程的解释，并覆盖适用的规则和限制以及适当时的使用示例。 还有一些表格汇总了有关过程的信息
* 附录E-包含在字符一章中的问题之一中使用的英语和拉丁语文本摘录，以及在第一章中的问题之一中使用的编码文本摘录。 14。
* 附录F-正式语法。
* 附录G－示例编译器选项

关于Fortran语言，这本书不是而且不可能完全独立且详尽。 我们的初衷是对功能进行全面介绍，以帮助您开始使用Fortran，并使您成功解决一系列问题。 总而言之，Fortran是一种令人兴奋的语言，并且已经赶上了过去50年中语言的发展。

## 1.2 程序范例
所有程序示例均可在以下连接在线获得：

[https://www.fortranplus.co.uk/](https://www.fortranplus.co.uk/)

所有示例都已使用Nag编译器抛光选项重新格式化。 这使程序具有一致的样式。 本书中的示例已经过格式化，行长为48个字符以适合打印页面。 然后对其进行手动编辑，以改善断线的位置。 该网站上的示例已被格式化为具有132个字符的行长。

## 1.3 网址
整本书都使用网址。 由于其中一些内容可能会在本书的整个生命周期中发生变化，因此我们的网站将提供最新的地址。 我们按章组织了它们。

# 第二章 解决问题概述
**目的**

本章的目的是：

* 研究解决问题所涉及的一些想法和概念。
* 介绍算法的概念。
* 介绍两种解决算法问题的方法。
* 介绍与系统分析和设计有关的想法，即表明在使用计算机系统之前需要进行铅笔和纸质学习。
* 引入统一建模语言-UML，它是软件工程领域中使用的通用建模语言。
## 2.1 介绍
考虑问题的一些字典定义是有益的：

* 分庭难以解决或解决的问题。
* 提出解决问题的难题，钱伯斯。
* 困惑之源，钱伯斯。
* 牛津大学，有疑问或困难的问题。
* 牛津大学，必须要做的事情。
* Webster提出的问题，以进行查询，考虑或解决。
* 复杂的未解决的问题，韦伯斯特的。

一个共同的话题似乎是我们想要回答或解决的问题。 因此，解决问题时要考虑的第一件事是如何提出问题。 这通常并不像看起来那样容易。 这里使用的两种最常见的方法是：

* 用自然语言
* 用人工或风格化的语言

两种方法各有优缺点。

## 2.2 自然语言
大多数人使用自然语言并熟悉自然语言，最常见的两种形式是书面和口头表达。 请考虑以下语言用法：

* 3岁儿童和成人描述世界的区别
* 工程师和物理学家进行汽车发动机设计的方式之间的差
* 考虑引入新技术的影响的经理和工人之间的区别

使用自然语言定义问题和解决方案时必须格外小心。 人们可能使用相同的语言来表示完全不同的事物，并且在解决问题时使用自然语言时必须意识到这一点。

自然语言也可能模棱两可：男女老少都吃奶酪。 男人和女人都老了吗？

## 2.3 人工语言
人工语言的两种最常见形式是技术术语和符号。 技术术语通常包括新单词的使用和现有单词的替代使用。 考虑以理论和实践方式检查气体膨胀时有用的一些概念：

* 温度
* 压力
* 质量
* 等温膨胀
* 绝热膨胀

现在查看以下内容：

* 厨师使用高压锅
* 在汽车发动机上工作的车库机械师
* 医生监测血压
* 设计燃气轮机的工程师

每个人都有一个特定的问题要解决，每个人都将以自己的方式解决他们的问题。 因此，他们每个人都会以略有不同的方式使用相同的术语。

### 2.3.1 记号
符号的一些示例是：

* 代数
* 微积分
* 逻辑

以上所有内容均已用作表示问题及其解决方案的符号。

## 2.4 摘由
因此，我们有两种描述问题的方式，它们都有一个学习阶段，直到我们获得足够的理解以有效地使用它们为止。 得出满意的问题陈述后，我们接下来必须考虑如何获得解决方案。 在这里，算法方法的功能变得有用。

## 2.5 算法
算法是解决部分或全部问题的一系列步骤。 配方是最容易理解的算法示例之一。 大多数人做饭，即使只是烤面包和煮鸡蛋。

食谱由两部分组成：

* 所需物品清单
* 步骤的顺序或顺序

在两个阶段都可能出现问题，例如，在食谱中途发现您没有配料或器皿； 发现一个阶段将花费一个小时，而其余阶段将在十分钟内准备就绪。 请注意，某些事情可以以任何顺序完成-如果您在胡萝卜之前准备土豆，则可能没有任何区别。

使用计算机时，有两种解决问题的方法。 它们都涉及算法，但是彼此之间有很大的不同。 它们被称为自上而下和自下而上。

名称算法源自九世纪波斯数学家阿布·贾法尔·穆罕默德·本·穆萨·阿·库瓦里兹米（贾法尔·穆罕默德的父亲，摩西的儿子，库瓦里兹米的名字）的名字，在西方文化中已被破坏为Kuwarizmi。

### 2.5.1 自顶向下
自上而下的方法是首先从较高或一般的角度指出问题：准备一顿饭。 然后将其精制，直到溶液中的每个步骤都明确且按正确的顺序进行操作为止，例如将洋葱去皮并切成薄片，然后在煎锅中将其变成棕色，然后再添加牛肉。 这种方法的一个缺点是很难向初学者进行授课，因为他们很少了解自己可以使用哪些原始工具。 另一个缺点是它们通常会错误地排序，例如，现在放置在中等温度的烤箱中令人沮丧，因为您可能没有点燃烤箱（序列问题），其次是因为您可能不知道中等温度的温度到底有多高。 但是，随着越来越多的问题得到解决，自上而下成为最有效的编程方法之一。

### 2.5.2 自底向上
自下而上是自上而下的反向！ 与以前一样，从高级别定义问题（例如准备一顿饭）开始，但是现在正在研究可以使用哪些工具等来解决问题。 由于可以构建大量工具并且可以解决更复杂的问题，因此该方法适合进行教学。 回顾一下食谱，如果您唯一能做的就是煮鸡蛋并打开一罐豆子，那么尝试煮六道菜就没有多大意义了。 因此，自下而上的方法对初学者具有优势。 但是，如果没有合适的工具可用，可能会出现问题。 作者的一位同事和朋友学会了如何制作调味酱，并且对他的成功感到非常高兴，以至于每顿饭都使用调味酱调味。 一天早上试一下鸡蛋。 在这种情况下，您需要确定问题，准备饭菜，并使用不合适但合理的工具调味酱。

解决实际问题，在需要时引入构造并解决它所付出的努力是相当大的。 这种方法可能不会导致对语言的合理全面覆盖，或者从教学角度来看特别有用。 案例研究确实具有很大的价值，但是如果您在开始学习基本规则之前有所了解，它会有所帮助。 想象一下，甚至在看一本法语语法书之前，通过学习Balzac来学习法语。 您可以通过这种方式学习，但是即使您已经学完，也可能无法与法国人说话并被理解。 案例研究方法的一个很好的例子在Kernighan和Plauger撰写的《软件工具》一书中给出。

在本书中，我们的目标是逐步引入越来越多的工具，直到您足够了解使用自上而下的方法解决问题为止，并且还不时意识到有必要开发一些新工具。

### 2.5.3 逐步细化
以上两种技术都可以与所谓的逐步优化相结合。这种方法背后的原始思想在Wirth于1971年发表的题为“逐步完善程序开发”的论文中得到了很好的表达。这意味着您要从全局问题陈述开始，然后逐步将问题分解为越来越小的子部分。问题变得越来越容易解决。刚开始编程时，可以解决的问题非常简单，但是随着经验的增长，您会发现您可以处理更复杂的问题。

当您想到解决问题的方式时，您可能会意识到，除非问题如此简单以至于您可以直接回答，否则需要一些思考和铅笔和纸上的工作。某些人可能会熟悉的一个例子是在一门科学学科的实践工作中，对这种情况毫无准备可能会非常沮丧和无益。因此，在使用计算机之前，应先考虑进行分析和设计的方式。

## 2.6 模块化编程
随着我们尝试解决的问题变得越来越复杂，我们需要研究管理由许多部分组成的程序的方法。 模块化2是最早支持这种方法的语言之一，我们将在下一章中更深入地讨论模块化编程。

## 2.7 面向对象编程
通过将这些问题的组成部分视为对象，可以最好地解决一类问题。下一章将介绍面向对象编程和面向对象语言中涉及的概念。

## 2.8 系统分析与设计
当人们开始编程时，通常并不明显需要采取一种方法来成功成为一名程序员。 这通常是因为问题相当简单，因此无需明确说明解决方案所经历的所有阶段。 随着问题变得越来越复杂，有必要使自己的方法变得更加严格和彻底，以面对不断增加的复杂性保持控制并避免犯错。 这样一来，系统分析和设计的好处就变得显而易见。 大体上，我们在系统分析和设计中具有以下阶段：

* 问题定义
* 可行性研究和事实调查
* 分析
* 初始系统设计
* 详细设计
* 实施
* 评估
* 维护

我们解决的每个问题在每个阶段所花费的时间会略有不同。 让我们更详细地研究每个阶段。

### 2.8.1 问题定义
在这里，我们有兴趣定义问题的实质。 我们应该旨在对问题的范围和我们设定的目标进行一些限制。我们可以使用前面提到的方法来帮助我们。 目标至关重要：

* 明确规定
* 当涉及一个以上的人时，所有有关人员都理解并同意
* 现实的
### 2.8.2 可行性研究和事实调查
在这里，我们看是否有可行的解决方案，我们将尝试估算解决问题的成本，并查看投资是否受到收益（即成本效益分析）的保证。

### 2.8.3 分析
在这里，我们了解解决该问题必须采取的措施。 请注意，我们有兴趣找出我们需要做的事情，但是在此阶段我们实际上并未这样做。

### 2.8.4 初始系统设计
分析完成后，我们知道必须执行的操作，然后可以继续进行设计。我们可能会发现多种选择，因此我们研究了解决问题的替代方法。 在这里，我们使用自上而下和自下而上的问题解决技术，并结合逐步改进，以生成解决问题的算法。 我们现在正在从解决方案的逻辑方面转向物理方面。 该阶段以几种选择中的一种选择结束。 请注意，通常没有一种理想的解决方案，而是几种，每种解决方案都有自己的优缺点。

### 2.8.5 详细设计
在这里，我们从一般转向特定。此阶段的最终结果应该是一个规范，该规范必须严格定义以生成实际的程序代码。

在此阶段，生成伪代码很有用。 这意味着详细写出我们希望在整个算法的每个阶段执行的操作。 我们逐步扩展每个阶段（逐步完善），直到它成为Fortran或我们想要的任何语言。

### 2.8.6 实施
正是在这个阶段，我们实际上使用计算机系统来创建可以解决该问题的程序。 在这里，我们实际上需要对某种编程语言有足够的了解，才能有效地使用它来解决我们的问题。 这只是整个过程的一个阶段，任何阶段的错误都会造成严重的困难。

### 2.8.7 评估与测试
在这里，我们尝试查看所生成的程序是否能够真正实现其应有的功能。我们需要具有使我们有信心地说该程序确实有效的数据集。 这可能不是一件容易的事，因为通常我们只有数字方法来解决问题，这就是为什么我们首先使用计算机的原因。因此，我们依靠计算机来提供证明； 也就是说，我们必须使用计算机来确定程序的准确性-正如Heller所说的，Catch 22。

### 2.8.8 维护
很少会运行一次程序，而永远不会再次使用它。 这意味着维护该程序将是一项持续的任务，通常是使其能够与操作系统或编译器的不同版本一起使用，并合并原始设计中未包含的新功能。 当人们开始编程时，程序将需要维护，这似乎很奇怪，因为我们不愿意将程序视为与诸如汽车之类的机械物体一样，最终会因使用而破裂。 因此，维护意味着使程序保持在一定的可容忍水平上运行，通常需要投入大量的人力和资源。 该领域的研究表明，程序中高达80％的人力投资都可以用于维护。

## 2.9 统一建模语言-UML
UML是在软件工程领域中使用的通用建模语言。 它是由Grady Booch，Ivar Jacobson和James Rumbaugh于1990年代在Rational Software工作时开发的。 它们是当时面向对象软件方法的三个主要代表，并决定统一各自开发的各种方法。

UML结合了数据建模（实体关系图），业务建模（工作流程），对象建模和组件建模的技术。 它可以在整个软件开发生命周期中，并在不同的实现技术中与所有流程一起使用。

它往往在业务计算中比在科学计算中使用更多。

## 2.10 总结
通常，在编程和问题解决的所有方法中固有的缺点是，假设确实存在解决方案。有些问题是无法解决的，不仅是诸如平衡国家预算，预测一年的天气预报或预测哪个放射性原子将衰变之类的问题，而且还有显然可以通过计算解决的问题。

克努斯（Knuth）举了一个国际象棋问题的例子-确定游戏是否是白人的强制胜利。尽管有一种算法可以做到这一点，但它需要很长的时间才能完成。出于实际目的，这是无法解决的。

其他问题可以用数学方法证明是无法确定的。哥德尔在这一领域的工作具有极其重要的意义，参考书目中有许多参考资料供那些更好奇，更注重数学的读者参考。 Hofstader的覆盖范围是最简单且数学最少的。

我们将尽可能地将自己限制在可解决的问题上，例如学习编程语言。

在计算机科学的正式世界中，我们对算法的描述将被认为有些松懈。对于我们的入门需求而言，这是足够的，但是Hopcroft和Ullman在“自动机理论，语言和计算导论”中以及Beckman在编程的数学基础中给出了更为严格的方法。

## 2.11 问题
2.1 什么是算法？

2.2 从上至下与自下而上的解决问题的方法有什么区别？ 参考汽车，摩托车或自行车轮胎漏气的问题来说明您的答案。

# 第三章 编程语言简介
**目的**

本章的主要目的是提供一段简短的程序语言开发历史，并就对Fortran产生影响的概念给出一些想法。 它按时间顺序将重点放在过去40年中的一些但不是全部主要里程碑上。 第二个目的是显示可用语言的广度。 本章以少数几种更专业的语言作为结束。

## 3.1 介绍
重要的是要认识到编程语言是最近的发明。 它们是在相对较短的时间内（60年）开发的，并且仍在不断改进中。 花时间获得一些历史观点将有助于您理解和评估未来的变化。 本章从一开始就开始，并带您了解这55年间的一些（但不是全部）发展。 本章的大部分内容描述了可以在商业上广泛使用的语言，因此很可能会遇到。 本章以一些更专业和/或最新的发展作为结束。

## 3.2 一些早期的理论工作
早期在计算领域最重要的理论工作是Turing和von Neumann的工作。 图灵的工作提供了基础，可以证明有可能获得一台机器来解决问题。 冯·诺依曼（von Neumann）的作品增加了存储的概念，并与图灵（Turing）的作品相结合，为当今设计的大多数计算机提供了基础。

## 3.3 什么是编程语言？
对于许多人来说，编程语言提供了一种使数字计算机解决问题的方法。 问题种类繁多，编程语言也种类繁多，其中特定的语言适合特定类别的问题，对于初学者而言，所有这些似乎都令人困惑。

## 3.4 程序语言开发与工程
编程语言的开发与工程界的任何事物的开发之间都有很多共同点。 考虑一下汽车：旧汽车与现代汽车具有许多相同的功能，但是大多数人都喜欢驾驶新车型。 编程语言也是如此，您可以使用较旧的语言实现很多目标，但是较新的语言更易于使用。

## 3.5 早期
在讨论编程语言时被证明非常有用的概念是机器级别的概念。 这表示语言与程序在其上运行的基础计算机的距离有多近。 在编程的早期（直到1954年），只有两大类：机器语言和汇编器。 数字机器使用的语言是0和1的语言，即它们是二进制设备。 用0和1的模式编写程序并不是特别令人满意，并且很快引入了使用更有意义的助记符的功能。 因此，很快就意识到编程语言最重要的方面之一就是机器和人类都必须阅读和理解它们。

### 3.5.1 Fortran的起源
下一阶段是开发高级语言。 其中第一个是Fortran，它是由John Backus领导的IBM团队在1954年至1957年的三年时间内开发的。 该小组取得了相当大的成功，并帮助证明了前进的道路在于使用高级语言来解决基于计算机的问题。 Fortran代表公式翻译，主要由具有科学背景的人用于解决具有重要算术内容的问题。 因此，目前在Fortran中表达此类问题相对容易。

到1966年，第一个标准的Fortran：

* 被广泛使用
* 很容易教
* 展示了子例程和独立编译的好处
* 相对机器独立
* 通常有非常有效的实现

关于Fortran的唯一最重要的事实可能是，并且至今仍在科学界广泛使用。

### 3.5.2 Fortran 77
1977年的下一个标准（实际上是1978年，因此被淘汰了-一个非常常见的编程错误，以后还会更多！）增加了许多重大改进，包括

* 带有可选的ELSE和ELSE IF子句的Block IF和END IF语句可为结构化编程提供改进的语言支持
* DO循环扩展，包括参数表达式，负增量和零跳闸计数
* OPEN，CLOSE和INQUIRE语句可改善I / O功能
* IMPLICIT语句，以覆盖未声明变量为INTEGER的隐式约定，如果它们的名称以I，J，K，L，M或N开头（否则为REAL）
* CHARACTERdata类型，用大大扩展的功能替换Hollerith字符串，用于字符输入和输出以及基于字符的数据处理
* 用于指定常量的PARAMETER语句
* 持久性局部变量的SAVE语句
* 内在函数的通用名称
* 一组用于字符串的词法比较的内在函数（LGE，LGT，LLE，LLT）

有时被忽略的一项重要功能是向后兼容。这意味着该标准不会使任何符合标准的Fortran 66程序无效。这样可以保护对旧代码的投资。

### 3.5.3 Cobol
商业界也意识到计算机是有用的，并且开发了多种语言，包括FLOWMATIC，AIMACO，Commercial Translator和FACT，最终导致了Cobol — COmmon商业导向语言。 商业编程中需要用比科学编程更为复杂的方式描述数据，而且Cobol在这一领域的能力比Fortran大得多。 该语言在当时是独一无二的，因为一组竞争对手共同致力于开发一种在其他制造商使用的机器上有用的语言。

Cobol的贡献包括：

* 首先是以下各项之间的分离：
  * 要执行的任务
  * 有关数据的描述
  * 在其中执行任务的工作环境
* 其次，数据描述机制在很大程度上与机器无关
* 第三，其处理大型文件的有效性
* 第四，易于阅读的编程语言将带来好处

计算的现代发展—报表生成器，文件处理软件，第四代开发工具，尤其是商业关系数据库管理系统可用性的不断提高—除非高效和/或严格控制，否则将逐渐取代Cobol的使用。

### 3.5.4 Algol
1950年代的另一个重要发展是Algol。 它具有从最初的Algol语言Algol 58到Algol 60一直到修订的Algol 60报告的发展历史。 Algol 58的一些设计标准是：

* 该语言应尽可能接近标准数学符号，并且应在不作进一步解释的情况下可读
* 应该可以使用它来描述出版物中的计算过程
* 新语言应可机械翻译为机器程序

Algol 58的一个令人遗憾的功能是缺少任何输入/输出功能，这意味着不同的实现在该领域通常具有不兼容的功能。

Algol的下一个重要步骤发生在1959年6月联合国教科文组织赞助的会议上。对Algol进行了公开讨论，结果是Algol 60，最后是Algol 60报告修订版。

正是在这次会议上，约翰·巴科斯（John Backus）发表了他现在著名的有关定义一种语言语法的方法的论文，该方法称为巴科斯范式（BNF）。 这篇论文的全部意义尚未得到立即认识。 但是，BNF的目的在于证明其在语言定义中的巨大价值，并帮助提供与计算语言学的接口。

Algol对程序语言开发的贡献包括：

* 块结构
* 由于块结构，变量的作用域规则
* Backus的BNF定义-现在大多数语言都有正式定义
* 递归的支持
* 它的后代

因此，Algol被证明为编程语言做出了贡献，而Algol 60本身的使用却从未体现过这一点，因为Algol一直是程序语言开发的主要部分之一。

## 3.6 乔姆斯基和程序语言开发
编程语言具有相当大的语言学意义，Chomsky在1956年在这一领域的工作被证明具有不可估量的价值。 乔姆斯基的转换语法系统是为了给语言的某些方面提供精确的数学描述而开发的。 简而言之，乔姆斯基描述了语法，这些语法又可以用来定义或生成相应种类的语言。 可以证明，对于每种语法和语言，都有相应的机器类型。 人们很快意识到与图灵的早期工作有联系。

该链接帮助为编程语言开发提供了坚实的科学基础，并且现代的编译器编写距Backus及其在IBM团队的早期工作还有很长的路要走。 在家里或在街机上玩电子游戏时，似乎并不重要，但是对于某些人来说，所有乐趣背后都有牢固的理论基础，这令人感到非常安慰。

## 3.7 Lisp
在非常专业的领域也有发展。事实证明，列表处理在1950年代引起了极大的兴趣，并且在1954年至1958年之间看到了IPLV的发展。这反过来又导致了1950年代末Lisp的发展。事实证明，Lisp在人工智能，下棋，自动定理证明和一般问题解决领域的编程中具有相当大的用途。它是最早被解释而不是被编译的语言之一。尽管解释型语言在使用底层计算机系统方面总是比编译型语言慢且效率低下，但它们确实为用户提供了一个很好的机会，使用户坐在终端时可以探索和尝试各种想法。这给计算问题解决者带来的力量是巨大的。

Lisp对程序语言开发的最大贡献可能是其功能符号。 Lisp用户面临的主要问题之一是大量的Lisp调味品，这减少了该语言已产生并应有的影响。

## 3.8 Snobol
Snobol的开发旨在帮助字符串处理，这被视为许多计算任务（例如程序解析）的重要组成部分。 Snobol展示的最重要的事情可能是编程语言中的模式匹配功能，例如，可以为标题定义一个模式，包括Mr，Mrs，Ms，Miss，Rev等，并进行搜索 使用Snobol在文本中显示此模式。 与Lisp一样，它通常可以作为解释器而不是编译器使用，但是确实存在编译版本，并且通常称为Spitbol。 模式匹配功能现在可以在许多编辑器中找到，这使它们成为功能强大且有用的工具。 在文本处理领域，Snobol对程序语言开发的最大贡献在于。

## 3.9 第二代语言
### 3.9.1 PL/1和Algol 68
Fortran，Algol 60和Cobol是三大主要的第一代高级语言。 1960年代出现了PL / 1和Algol68。PL/1是Fortran，Algol 60和Cobol功能的综合。 很快就意识到，尽管PL / 1具有丰富的表达能力，但在某种程度上却被语言定义和使用中的更大困难所抵消。

后面这些问题在Algol 68上也适用。该报告介绍了自己的句法和语义约定，因此将预期用户的学习过程推向了另一个阶段。 但是，它的用户数量很少但非常忠诚，他们喜欢该语言提供的非常丰富的功能。

### 3.9.2 Simula
构成程序语言开发的另一部分内容由Simula提供，Simula是由挪威计算中心的Dahl，Myhrhaug和Nygaard开发的一种通用编程语言。 Simula所做的最重要的贡献是提供了语言结构，以帮助编程复杂的，高度交互的问题。 因此，它在仿真和建模领域大量使用。 它实际上是第一种提供面向对象编程的机会的语言，我们将在本章后面的部分回到编程语言的这一非常重要的发展。

### 3.9.3 Pascal
Pascal的设计师Niklaus Wirth参与了Algol 68设计的早期阶段，但认为Algol 68的通用性和复杂性是朝错误的方向发展。 Pascal（如Algol 68）起源于Algol 60，但其目标是通过一小组简单的概念来提供表达能力。这套工具相对易于学习，有助于制作可读性强，易于理解的程序。

它在1970年代和1980年代成为计算机科学领域的首选语言，Wirth的评论很好地总结了该语言：“尽管Pascal没有得到行业，专业团体或政府机构的支持，但它已被广泛使用。 。取得成功的重要原因是，许多有能力认识到其潜力的人积极地参与了其推广。与良好实现的存在同样重要的是文档的可用性。原始报告的简洁性使它吸引了许多教师，将其扩展为有价值的教科书。 1977年至1985年之间出现了无数书籍，有效地促进了Pascal成为入门编程课程中使用最广泛的语言。好的课程资料和实施是这种发展必不可少的前提。”

### 3.9.4 APL
APL是1960年代初的另一种有趣的语言。 它是由艾弗森（Iverson）在该年代初期开发的，并于1960年代中期至后期推出。 它是一种基于解释性矢量和矩阵的语言，具有广泛的运算符集，可用于处理任何数据类型的矢量，数组等。 与Algol 68一样，它的用户数量很少，但敬业度很高。 关于APL程序的一个可能不公平的评论是，您不调试它们，而是重写它们！

### 3.9.5 Basic
Basic代表“初学者通用符号指令”，由Kemeny和Kurtz在1960年代在达特茅斯开发。 它的名字为听众提供了一个线索，并且很容易学习。 尽管确实存在编译版本，但通常会对其进行解释。 它已被证明非常适合小型程序的快速开发。 人们批评它，因为它缺乏鼓励或强迫采用声音编程技术的功能。

### 3.9.6 C
在计算中需要能够直接或至少有效地访问底层机器。因此，计算机专业人员开发高级语言来做到这一点不足为奇。这看起来很矛盾，但是可以做到的程度令人惊讶。最早发表的一些著作是马丁·理查兹（Martin Richards）关于BCPL的发展。

这种语言直接影响了Ken Thompson的工作，并且可以在编程语言B和C中清楚地看到。UNIX操作系统几乎完全是用C编写的，并且非常清楚地展示了使用高级语言的好处。

随着UNIX在学术界的广泛使用，C在1970年代和1980年代获得了可观的发展。 UNIX系统还为专业软件开发人员提供了很多东西，并被广泛用于大规模软件开发，正如Ritchie所说：“ C是古怪的，有缺陷的，并且取得了巨大的成功。尽管历史上的偶然事件肯定会有所帮助，但它显然满足了对一种系统实现语言的需求，该语言应足够高效以替换汇编语言，但又要足够抽象和流利，可以在各种环境中描述算法和交互。”

C有多种版本。在对语言进行标准化之前，大多数人都依赖Dennis Ritchie和Brian Kernighan在书中包含的非正式规范，该版本称为K＆RC。1989年，美国国家标准协会发布了ANSI C或C89。标准。一年后成为ISO标准。 K＆R书的第二版涵盖了ANSI C标准。 ISO随后在1995年发布了对该标准的国际化支持的扩展，并在1999年发布了修订的标准（C99）。

C99引入了一些新功能，包括内联函数，几种新数据类型（包括long long int和表示复数的复杂类型），可变长度数组，对IEEE 754浮点的改进支持，对variadicmacros（可变Arity宏）的支持），并支持以//开头的单行注释，这是C ++的一部分。这增加了C和C ++的兼容性，其中许多已在多个C编译器中作为扩展实现。

该标准的最新版本-C11于2011年12月获得批准。

C11标准为C和库添加了一些新功能，包括类型通用宏，匿名结构，改进的Unicode支持，原子操作，多线程和边界检查功能。它改善了与C ++的兼容性。

## 3.10 语言发展的其他方面
构成程序语言开发的环节很多，此处介绍其中的一些环节。

### 3.10.1 抽象、逐步完善和模块
实践证明，抽象在编程中非常重要。 它使复杂的任务分解为较小的部分，从而专注于我们想要发生的事情，而不是我们希望如何发生。 这几乎自动导致逐步完善和模块的思想，以及执行特定任务或步骤的模块集合。

### 3.10.2 结构化程序设计
从最狭义上讲，结构化编程与使用少量但足够的语句集，尤其是控制语句的程序开发有关。 它对程序语言设计产生了很大的影响，现在大多数语言都支持最少的控制结构集。

从广义上讲，结构化编程包含其他目标，包括程序的简单性，可理解性，可验证性，可修改性和可维护性。

### 3.10.3 数据结构与程序编程
到1970年代，开始出现了提供逻辑组织数据的能力的语言-所谓的数据结构化，下面我们将介绍其中的两种-C和Pascal。

C通过结构提供了此功能，而Pascal通过记录提供了此功能。 这些语言还提供了两种处理数据的方式-直接或通过过程。 文献中有时还会使用术语具体和抽象数据类型。

一个示例可能会有所帮助。 考虑一个日期。 它通常由一天，一个月和一年的三个部分组成。 在C语言中，我们可以使用结构创建用户定义的类型，称为日期。 然后，我们可以创建这种类型的变量。 在Pascal中，使用记录的方式与此类似。

然后，可以直接访问日期（日，月和年）的组成部分（具体数据类型的示例），也可以间接（通过过程）访问抽象数据类型。

简单地直接访问（或具体的数据类型）提供了效率的好处，并且可能缺乏数据完整性。 在我们的日期示例中，当月份为2月时，我们可以将日期设置为31。

间接访问（或抽象数据类型）的效率稍有降低，因为我们现在需要过程调用来访问数据，但由于我们可以在过程中提供隐藏代码以确保日，月和日，因此有更好的数据完整性机会。 年份组合有效。

直到Fortran 90标准，Fortran才提供此功能。

### 3.10.4 标准化
标准的目的千差万别，包括：

* 对人的投资：这意味着我们花在学习一种标准语言上的时间将长期回报，因为人们所学的知识可适用于任何具有标准一致性编译器的硬件/软件平台。
* 可移植性：一个人可以拿一个人为一个硬件/软件平台编写的代码，然后将其移动到具有标准一致性编译器的任何硬件/软件平台。
* 已知参考点：进行比较时，首先要参考标准，然后再参考各种实现的其他功能

这些是使用标准的部分原因，但并非全部原因。 Ronald G. Ross在有关SQL标准的Cannan和Otten书的介绍中很好地总结了它们的重要性：“任何将电源线插入壁装电源插座的人都可以容易地体会到可行标准的不可估量的好处。的确，就电力而言，我们甚至很少考虑这种访问（直到出现问题）的事实，确实证明了成功标准的重要性。”

## 3.11 Ada
艾达（Ada）代表着程序语言开发领域多年工作的高潮。 这是集体的努力，其主要目的是产生一种适用于对大型实时系统进行编程的语言。 1974年开始工作，当时美国国防部（DoD）制定了一系列文件，最终形成了Steelman文件。 它是一种现代算法语言，具有用于模块使用的常规控制结构和设施，并允许在模块之间进行类型检查的单独编译。

Ada是一种功能强大且精心设计的语言。 由于它具有国防部的支持，因此它的广泛使用是肯定的。 但是，它是一种庞大而复杂的语言，因此需要进行一些学习。

该语言的最新版本是Ada2012。以下网址

[http://www.ada-europe.org/resources/online](http://www.ada-europe.org/resources/online)

提供了一个很好的起点。 如果您想要有关Ada的最新详细信息，请访问此网站。

另一个好的来源是

[http://www.adaic.org/ada-resources/standards/ada12](http://www.adaic.org/ada-resources/standards/ada12)

这两个站点都有各种Ada标准的免费电子版本。

## 3.12 Modula
Modula由Wirth于1970年代在ETH进行设计，用于嵌入式实时系统的编程。 它具有Pascal的许多功能，一眼就能被Pascal接受。 Modula引入的关键新功能是流程和监视器的功能。

与Pascal一样，它相对容易学习，这对大多数人来说，它比Ada更具吸引力，可以在不复杂的情况下实现很多功能。

## 3.13 Modula 2
Wirth继续发展其关于编程语言的思想，其高潮可以在Modula 2中看到。用他的话说：“ 1977年，一个旨在以集成方法设计计算机系统（硬件和软件）的研究项目， 在苏黎世联邦理工学院的信息研究所成立。 该系统（后来称为Lilith）将使用一种高级语言进行编程，因此必须满足高级系统设计以及与给定硬件紧密交互的零件的低级编程的要求。 模块化2是经过精心设计的考虑而产生的，该语言包括Pascal的所有方面，并通过重要的模块概念和多程序设计对其进行了扩展。 由于其语法比Modscal更符合Modula，因此选择的名称为Modula2。”

该语言在Pascal方面的主要新增功能包括：

* 模块的概念，尤其是将模块分为定义部分和实现部分的工具。
* 一种更系统的语法，有助于学习过程。 尤其是，每个以关键字开头的结构也都以关键字结尾，即正确地括起来。
* 过程概念是多重编程设施的关键。
* 所谓的低级设施，它有可能违反严格的类型一致性规则，并允许将具有Modula 2结构的数据映射到没有固有结构的存储中。
* 过程类型，它允许将过程动态分配给变量。

Modula 2的一个令人遗憾的功能是要花很长时间才能达到该语言的标准。

## 3.14 其他语言发展
以下是作者发现有趣的语言发展的一小部分选择-它们很可能未包含在其他人的报道中。

### 3.14.1 Logo
Logo是由Papert及其同事在麻省理工学院人工智能实验室开发的一种语言。 Papert是数学和教育学的教授，受到心理学家伯爵（Piaget）的极大影响。 该语言用于创建学习环境，儿童可以在其中与计算机进行通信。 该语言主要用于演示和帮助儿童发展数学的基本概念。 教育家可能会在徽标徽标之外知道乌龟和乌龟的几何形状。 在Xerox Palo Alto研究中心-Xerox PARC开发的Smalltalk计算机系统中已经集成了海龟。

### 3.14.2 Postscript, TEX and LATEX
1980年代，计算机在印刷材料生产中的使用迅速普及。 这三种语言在该领域中被广泛使用。

Postscript是具有良好图形功能的低级解释性编程语言。 其主要目的是使包含文本，图形形状和图像的页面的生成变得容易。 现代台式机发布系统的大多数最终用户很少看到它，但是这些系统中的许多是基础。 越来越多的激光打印机和排字机为它提供了支持。

TEX是由Donald Knuth开发的一种用于生成数学文本的语言。 它使用标准的计算机键盘线性化数学运算。 它在科学界广泛用于生成涉及数学方程式的文档。

LATEX是Leslie Lamport的TEX版本，被许多人认为更友好。 它基本上是一组宏，它们对最终用户隐藏原始TEX。 TEX比率可能是1–9（或者说TEXie确实告诉了我）。

### 3.14.3 Prolog
Prolog最初由Colmerauer领导的小组于1972/73年在马赛开发。 此后，它已经由Pereira（L.M.），Pereira（F），Warren和Kowalski等人进行了扩展和开发。 Prolog与众不同之处在于它是逻辑编程的载体。 此处描述的大多数语言基本上都是算法语言，并且要求您说明如何完成某项工作。 逻辑编程着重于什么而不是如何。 这种语言乍一看似乎很奇怪，但是由科瓦尔斯基（Kowalski）等人在伦敦的学校里教给10岁的孩子。

### 3.14.4 SQL
SQL代表结构化查询语言，它最初是由主要在San Jose研究实验室为IBM工作的人们开发的。 它是一种关系数据库语言，使程序员能够定义，操纵和控制关系数据库中的数据。 简而言之，用户将关系数据库看作是包含行和列的表的集合。 它已成为整个数据库领域中最重要的语言。

### 3.14.5 ICON
ICON与Snobol属于同一家族，是一种高级通用编程语言，具有有效处理非数值数据所需的大多数功能。 自从Snobol的设计和实现以来，Griswold（Snobol的原始设计团队之一）就学到了很多东西，并且在大多数文本操作领域中使用该语言都是一种乐趣。

大多数系统都可以通过Internet上许多站点上的匿名FTP通过大多数系统使用它。

## 3.15 面向对象编程
面向对象代表了程序语言开发的重大进步。 引入的概念包括：

* 类
* 对象
* 消息
* 方法

这些反过来借鉴了更常规的编程语言中发现的思想，并且与

* 可扩展的数据类型
* 类的实例
* 动态绑定的过程调用
* 课堂程序

继承是面向对象编程引入的一个非常强大的高级概念。 它使现有数据类型及其有效操作范围可以构成新类的基础，并为更多类型的数据添加了相应的操作，并且新类型与原始数据兼容。

Fortran 2003为面向对象的编程提供了支持。 这是通过模块工具而不是其他语言（例如C ++，Java和C＃）中的类工具实现的。

### 3.15.1 Simula
如前所述，这是在areawas Simula中提供功能的第一种语言，因此其思想起源于1960年代。 Birtwistle，Dahl，Myhrhaug和Nygaard撰写的《 Simula Begin》一书非常值得一读，因为它代表了介绍面向对象编程概念的第一本书。

### 3.15.2 Smalltalk
语言以及计算机系统的使用。

自1970年代以来，施乐PARC学习研究小组一直在开发Smalltalk。用他们的话来说：“ Smalltalk是一个图形化的交互式编程环境。正如个人计算机视觉所建议的那样，Smalltalk的设计使用户可以访问系统中的每个组件，并且可以以有意义的方式呈现它们以进行观察和操作。 Smalltalk中的用户界面问题围绕着为每个对象创建视觉语言的尝试。 Smalltalk的首选硬件系统包括高分辨率图形显示屏和指示设备，例如图形笔或鼠标。使用这些设备，用户可以选择在屏幕上查看的信息并调用消息以与该信息进行交互。”因此，Smalltalk在程序语言开发中代表了非常不同的一环。这种系统的易用性早已得到人们的认可，并首先在Macintosh微型计算机中得到了商业证明。

沃思（Wirth）在施乐PARC呆了一段时间，并受到他们工作的影响。 用他自己的话说：“最令人振奋的感觉是，在为计算机工作了十六年之后，现在计算机似乎为我工作了。” 这种影响可以从Lilith机器的设计，原始的Modula 2引擎以及Oberon作为语言和操作系统的开发中看出。

### 3.15.3 Oberon和Oberon 2
正如Wirth所说：“编程语言Oberon是致力于提高Modula-2功能并同时降低其复杂性的结果。 消除了一些功能，并添加了一些功能，以提高语言的表达能力和灵活性。”

因此，Oberon和Oberon 2是Modula 2之外的发展。Oberon添加的主要新概念是类型扩展。 这使得能够基于现有类型构造新的数据类型，并允许人们利用对该现有类型已经完成的工作。

删除的语言结构包括：

* 变体记录
* 不透明类型
* 枚举类型
* 子范围类型
* 本地模块
* 有陈述
* 类型传递函数
* 并发

沃思（Wirth）撰写的简短论文提供了更全面的报道。 它可以通过匿名FTP在ETH使用。

### 3.15.4 Eiffel
Eiffel最初由Bertrand Meyer创立的Interactive Software Engineering Inc.（ISE）开发。 Meyer的书《面向对象的软件构造》包含对导致Eiffel设计的对象技术的概念和理论的详细论述。

该语言于1986年首次可用，Meyer的书的第一版于1988年出版。以下是Wikipedia条目的引文。

>Eiffel语言，库和编程方法的设计目标是使程序员能够创建可靠的，可重复使用的软件模块。 Eiffel支持多重继承，通用性，多态性，封装，类型安全的转换和参数协方差。 埃菲尔对软件工程的最重要贡献是按合同设计（DbC），其中采用断言，前置条件，后置条件和类不变式来帮助确保程序正确性而不牺牲效率。
### 3.15.5 C++
Stroustrup在英格兰剑桥大学计算机实验室完成了博士学位论文，并曾与Simula合作。他曾在丹麦奥尔胡斯大学与Simula合作。 他的评论很有启发性：“但是，随着程序规模的增加，Simula语言的机制变得越来越有用的方式令人惊讶。 Simula的类和协同例程机制以及全面的类型检查机制可确保问题和错误不会（随着我-我猜想大多数人会想到的）不会随程序的大小线性增长。 相反，整个程序就像一个很小的程序（因此易于编写，理解和调试）的集合，而不是一个大程序。

他设计了C ++以在C的效率框架内提供Simula的功能，并且他成功实现了这一目标，因为C ++是使用最广泛的面向对象编程语言之一。

该语言最初是对C的增强，在第一个标准发布时就添加了类，虚函数，运算符重载，多重继承，模板和异常处理。

在Java和C＃中可以看出它对编程语言设计领域的影响。

表3.1总结了C ++标准化的历史记录。

以下是标准委员会在C ++ 11开发中使用的一些准则。

![图片](https://uploader.shimo.im/f/aHOMGav6oQH5nccX.png!thumbnail)

* 保持与C ++ 98以及可能与C的稳定性和兼容性；
* 优先通过标准库引入新功能，而不是扩展核心语言；
* 优先考虑可以发展编程技术的变更；
* 改进C ++以促进系统和库设计，而不是引入仅对特定应用程序有用的新功能；
* 通过提供更安全的替代早期不安全技术的方式来提高类型安全性；
* 提高性能和直接与硬件一起工作的能力；
* 提供针对实际问题的适当解决方案；
* 实施零开销原则（仅当使用实用程序时，才必须使用某些实用程序所需的附加支持）；
* 使C ++易于教授和学习，而无需删除专家程序员所需的任何实用程序。

C ++ 14是对C ++ 11的一个小扩展，于2014年12月发布。

C ++ 17是一个重大更新，于2017年12月发布。

### 3.15.6 Java
在1980年代后期，比尔·乔伊（Bill Joy）（Sun的成名人物）认为C ++太复杂了，应该使用基于C ++的面向对象的环境。大约在同一时间，James Gosling（先生emacs）开始对用C ++实现SGML编辑器感到沮丧。橡树是高斯林无奈的产物。

在接下来的几年中，Sun最终为各种项目开发了Oak。直到Sun开发了自己的网络浏览器Hotjava，Java才开始流行。俗话说，剩下的就是历史了。

Java是一种相对简单的面向对象的语言。尽管它起源于C ++，但它已取消了大多数危险功能。整个都是OO。一切都是一堂课。

它将被解释，并且中间字节代码将在具有Java虚拟机的任何计算机上运行。这是对象代码级别的可移植性，与源代码级别的可移植性不同（这是我们对大多数常规语言所期望的）。该语言的一些安全功能包括：

* 内置垃圾收集
* 数组下标检查
* 没有指针-一切都通过引用传递

它是多线程的，这使它对于许多应用程序来说都是一种乐趣。 它有一个广泛的Windows工具包，即最初的语言版本和后来发布的Swing中的所谓的AWT。

它正在持续发展中，在撰写本文时已是第八个主要版本。

Sun于2010年被Oracle收购。

### 3.15.7 C#
C＃是Microsoft的最新语言，是其.NET框架的关键部分。 它是一种现代的，精心设计的语言，与C，C ++和Java的语法在同一系列的编程语言中一样。 如果您了解这些语言中的一种，它将看起来非常熟悉。

设计目标之一是产生一种面向组件的语言，并以Microsoft在OLE，ActiveX和COM上所做的工作为基础：

* ActiveX是一套技术，可让软件组件在联网环境中相互交互，而与创建它们所使用的语言无关。 ActiveX建立在组件对象模型（COM）上。
* COM是在其上构建ActiveX控件和OLE的对象模型。 COM允许对象向其他组件和主机应用程序公开其功能。 它定义了对象如何公开自身以及该公开如何在流程和网络中工作。 COM还定义了对象的生命周期。
* OLE是一种机制，允许用户创建和编辑包含由多个应用程序创建的项目或对象的文档。 OLE最初是对象链接和嵌入的首字母缩写。 但是，现在简称为OLE。 OLE的与链接和嵌入无关的部分现在是Active技术的一部分。

其他设计目标包括创建语言：

* 凡事都是对象-C＃还具有一种在对象和基本类型（整数，实数等）之间切换的机制
* 这将使构建强大而可靠的软件成为可能-它具有垃圾回收，异常处理和类型安全性
* 它将使用众所周知的C / C ++ / Java语法，从而帮助程序员从这些语言之一转换为C＃

自原始版本以来，该版本已被更新了三次。 C＃2中添加的一些更重要的功能是泛型，迭代器，局部类，可空类型和静态类。 C＃3为大多数人添加的主要功能是LINQ，这是一种数据查询机制。 C＃4于2010年发布，并添加了许多其他功能。

### 3.15.8 Python
Python是一种面向对象的，解释性和交互式编程语言。 Python是在1980年代后期构想的，它的实现是1989年12月由荷兰CWI的Guido van Rossum开始的，它是ABC语言（其本身受SETL启发）的继承者，能够进行异常处理和与Amoeba操作系统的接口。 范·罗瑟姆（Van Rossum）是Python的主要作者，他在决定Python的方向上继续发挥着中心作用，这反映在Python社区（对生命的仁慈独裁者-BDFL）给他的头衔中。

以下是Guido van Rossum撰写的关于这一切的简短摘要：

>我在CWI的ABC小组中拥有实施解释型语言的丰富经验，通过与该小组的合作，我学到了很多关于语言设计的知识。这是许多Python功能的起源，包括使用缩进进行语句分组以及包含非常高级的数据类型（尽管Python中的细节都不同）。我对ABC语言有很多了解，但也喜欢它的许多功能。扩展ABC语言（或其实现）以补救我的投诉是不可能的，事实上，缺乏可扩展性是其最大的问题之一。我有一些使用Modula-2 +的经验，并与Modula-3的设计师进行了交谈，并阅读了Modula-3报告。 Modula-3是用于异常以及其他一些Python功能的语法和语义的起源。我在CWI的Amoeba分布式操作系统小组工作。我们需要一个更好的方法来进行系统管理，而不是编写C程序或Bourne Shell脚本，因为Amoeba有自己的系统调用接口，该接口不能从Bourne Shell轻松访问。我在变形虫中处理错误的经验使我敏锐地意识到异常作为编程语言功能的重要性。在我看来，一种脚本语言具有ABC之类的语法，但可以访问Amoeba系统调用，可以满足需要。我意识到编写特定于变形虫的语言是愚蠢的，所以我决定我需要一种通常可以扩展的语言。在1989年圣诞节假期期间，我的手头有很多时间，因此我决定尝试一下。在接下来的一年中，尽管我仍然主要从事Python的开发工作，但在Amoeba项目中使用了Python，并且取得了越来越大的成功，而同事们的反馈使我增加了许多早期改进。 1991年2月，经过一年多的发展，我决定发布到USENET。其余的位于“杂项/历史记录”文件中。

Python 2.0于2000年10月16日发布，具有许多主要的新功能，包括循环检测垃圾收集器和对Unicode的支持。 在此版本中，开发过程已更改，变得更加透明并得到社区的支持。

经过长时间的测试，Python 3.0（也称为Python 3000或py3k）是一个向后不兼容的主要发行版，于2008年12月3日发布。 它的许多主要功能已向后兼容到Python 2.6和2.7。

这是主要的Python网站

[https://www.python.org/](https://www.python.org/)

它被广泛使用。 使用Python的大型组织包括Google，Yahoo！，CERN和NASA。

当我们被Aldermaston的Atomic Weapons Establishment的工作人员问及Python培训时，我们就开始参与Python。 我们为他们安排了为期3天的短期强化课程。

非常有趣的语言！

## 3.16 回到Fortran
最后，我们将介绍自Fortran 77标准以来的发展。 目前，几乎所有可用的Fortran编译器都完全支持Fortran 90和95标准。 定期改进对Fortran 2003和2008标准的功能的支持。 请参阅以下文件

[https://www.fortranplus.co.uk/fortran-information/](https://www.fortranplus.co.uk/ fortran-information/)

获取有关每个编译器在标准支持方面提供的最新信息。

### 3.16.1 Fortran 90
几乎在Fortran 77标准完成并发布后，就开始开发下一个版本。 该语言借鉴了本章介绍的许多思想，这些思想使Fortran 90成为非常有前途的语言。 一些新功能包括：

* 新的源表格，其中空格有效，名称最多31个字符
* 无隐含
* 更好的控制结构
* 数值计算精度的控制
* 数组处理
* 指针
* 用户定义的数据类型和运算符
* 程序
* 模组
* 递归
* 动态存储分配

这是Fortran社区期待已久的重大更新。 向后兼容再次是主要目标。 该标准不会使任何符合标准的Fortran 77程序无效。

### 3.16.2 Fortran 95
Fortran在1996年进行了标准化，但又一次被淘汰！ 首先，我们要弄清标准中需要澄清的一些领域。 其次，Fortran 95添加了以下主要概念：

* 永恒的构造
* 纯程序和基本程序
* 派生类型对象的隐式初始化
* 指针的初始关联状态

前两个在代码并行化方面有很大帮助。

次要功能包括：

* 自动分配可分配数组
* 内在符号功能区分–0和+0
* 内部函数null返回断开连接的指针
* 内部函数cpu_time返回处理器时间
* 规范语句中允许引用某些纯函数
* 嵌套在哪里构造
* 在其他地方屏蔽
* 天花板，地板，最大位置和最小位置固有功能的微小变化

添加了其中一些以使Fortran与高性能Fortran（HPF）保持一致。 稍后给出更多细节。

该标准的第2部分（ISO / IEC 1539-2：1994）添加了用于可变长度字符数据类型的功能规范，这极大地扩展了Fortran在字符应用程序中的用途。

### 3.16.3 ISO技术报告TR15580和TR15581
在Fortran上还发布了另外两个报告。 TR 15580指定了三个模块，这些模块提供对IEEE浮点算术的访问，TR15581允许在伪参数，函数结果和结构组件上使用可分配的属性。

### 3.16.4 Fortran 2003
该语言被称为Fortran 2003，尽管该语言直到2004年才通过标准化过程。它是一个重大修订。

* 派生类型增强
  * 参数化派生类型（使用派生类型时，可以选择派生类型的组件的种类，长度或形状）
  * 混合组件可访问性（允许不同组件具有不同的可访问性）
  * 私人类型的公共实体
  * 改进的结构构造函数
  * 终结者
* 面向对象的编程支持
  * 增强的数据抽象（允许一种类型扩展另一种类型的定义
  * 类型）
  * 多态性（允许变量的类型在运行时变化）
  * 动态类型分配
  * 选择类型构造（允许选择执行流程，具体取决于当前多态对象的类型）
  * 类型绑定过程
* 关联构造（允许用简单符号表示复杂的表达式或对象）
* 数据处理增强
  * 可分配的组件
  * 延迟类型参数
  * 易失性属性
  * 数组构造函数中的显式类型规范
  * 指针参数的意图指定
  * 指定指针分配的下限，并重新分配指针等级
  * 扩展初始化表达式
  * 字符类型的最大和最小内在函数
  * 增强复数常数
* 输入/输出增强
  * 异步传输操作（允许程序在发生输入/输出传输时继续处理数据）
  * 流访问（允许访问文件而无需引用任何记录结构）
  * 用户指定的派生类型的传输操作
  * 用户指定的格式转换过程中的舍入控制
  * 刷新语句
  * 预连接单元的命名常量
  * 输入/输出关键字的正则化
  * 访问输入/输出错误消息
* 过程指针
* 作用域增强
  * 重命名已定义运算符的能力（支持更大的数据抽象）
  * 控制主机关联到接口主体中
* 支持IEC 60559（IEEE 754）例外和算术（在处理器的算术支持IEC标准的范围内）
* 与C编程语言的互操作性（允许便携式访问C提供的许多库和低级功能，并允许C编写的程序可移植地使用Fortran库）
* 支持国际使用
  * ISO 10646
  * 以数字格式的输入/输出选择小数或逗号
* 与主机操作系统的增强集成
  * 访问命令行参数和环境变量
  * 访问处理器的错误消息（提高了处理异常条件的能力）

较早的网址详细介绍了符合该标准的Fortran编译器。

### 3.16.5 DTR 19767增强模块功能
Fortran中的模块系统存在许多缺点，该DTR解决了一些问题。

主要问题之一是所谓的重新编译级联。 更改模块的一部分将强制重新编译使用该模块的所有代码。 模块化2通过区分定义或接口与实现来解决此问题。 现在，这可以在Fortran中通过子模块实现。

### 3.16.6 Fortran 2008
下一个标准，即ISO / IEC 1539-1：2010，通常称为Fortran 2008，于2010年9月获得批准。新功能包括：

子模块

* 协同数组
* 性能增强
  * 并发
  * 连续属性
  * 简单连续的数组
* 数据申报
  * 最高等级
  * 长整数
  * 递归类型的可分配组件
  * 隐式数组
  * 指针初始化
  * 取消了数据声明限制
  * 总体指数的一种
  * 内在类型的类型声明
  * 声明类型绑定过程
  * 值属性的扩展
* 数据使用
  * 省略结构构造函数中的可分配组件
  * 使用source =的多个分配
  * 在分配语句中复制对象的属性
  * 多态分配
  * 访问实部和虚部
  * 指针功能
  * 取消了基本的虚拟参数限制
* 输入输出
  * 打开文件时查找单元
  * g0编辑描述符
  * 无限格式项
  * 递归输入/输出
* 执行控制
  * 块构造
  * 退出声明
  * 停止码
* 内部程序和模块
  * 位处理
  * 储存空间
  * 将可选参数基数添加到所选实型
  * 三角函数和双曲内在函数的扩展
  * 贝塞尔函数
  * 错误和伽玛功能
  * 欧几里得向量规范
  * 平价
  * 执行命令行
  * 将可选参数返回添加到maxloc和minloc
  * 查找数组中的位置
  * 字符串比较
  * 常数
  * 编译器信息
  * C sizeof的函数
  *  ieee_selected_real_kind的附加可选参数
* 程序和程序
  * 保存模块和子模块数据的属性
  * 空包含部分
  * 内部或模块过程的结束声明的形式
  * 内部过程作为实际参数或指针目标
  * 空指针或未分配的可分配项，作为缺少的伪参数
  * 指针虚拟参数的非指针实际值
  * 通过指针/可分配或数据/过程的通用解析
  * 不纯净的基本程序
  * 进入声明变得过时
* 源表格
  * 行开始处的分号

约翰·里德（John Reid）的论文中有更详尽的报道

[https://wg5-fortran.org/N1851-N1900/N1891.pdf](https://wg5-fortran.org/N1851-N1900/N1891.pdf)

### 3.16.7 TS 29113 Fortran与C的进一步互操作性
该TS于2012年发布。

### 3.16.8 Fortran 2018
根据当前的WG5工作时间表，预计Fortran 2018标准将于2018年8月发布。

这是此标准引入的一些更改的简短列表。 它取材于约翰·里德（John Reid）关于Fortran 2018新功能的论文。该论文的第一版为N2127，于2017年出版。第二版为N2145，于2018年1月出版。

* Fortran中的其他并行功能
  * 团队
  * 图像故障
  * 组队声明
  * 变更团队架构
  * 团队中分配的协数组
  * 关键构造
  * 锁定和解锁语句
  * 同步团队声明
  * 图像选择器
  * 内部功能获取团队和团队编号
  * 本质功能图像索引
  * 内在函数num图像
  * 固有功能此图像
  * 内部函数移动分配
  * 失败的图像声明
  * 检测失败和停止的图像
  * 集体子程序
  * 新增和增强的原子子例程
  * 失败的图像和状态=说明符
  * 活动
* 符合ISO / IEC / IEEE 60559：2011
  * 次标准值
  * 浮点模式的类型
  * 从零舍入
  * 小数舍入模式
  * 舍入转换
  * 融合乘法加法
  * 测试标志
  * 转换为整数类型
  * 剩余功能
  * 最大值和最小值
  * 相邻的机器编号
  * 比较
* 消除缺陷和差异
  * 从模块访问的实体的默认可访问性
  * 隐式无增强
  * 增强查询
  *  d0.d，e0.d，es0.d，en0.d，g0.d和ew.d e0编辑描述符
  * 格式化的输入错误条件
  * 通用程序规则
  * 停止和错误停止的增强
  * 访问计算环境的本征
  * 新的元素固有函数超出范围
  * 新的还原固有还原
  * 内在函数共形
  * 内部子例程随机初始化
  * 本征功能标志
  * 内部函数扩展类型，并与
  * 来自标准内部模块的非标准程序
  * 隐含的do中的do变量的种类
  * 并发中的局部性子句
  * 主机关联的控制
  * 将文件连接到多个设备
  * 使用size =提前输入
  * 通用声明的扩展
  * 消除有关纯程序的异常
  * 递归和非递归程序
  * 简化内部cmplx的调用
  * 取消了对许多内在函数的参数变暗的限制
  * 内在和IEEE程序的论点
  * 十六进制输入/输出
  * 删除
    * 算术是否
    * 非阻塞做构造
  * 新的过时
    * 共同与对等
    * 带标签的do语句
    * 内在函数的特定名称
    * 全面的结构和声明

N2127和N2145都可以在WG5站点上找到。

[https://wg5-fortran.org/documents.html](https://wg5-fortran.org/documents.html)

这两个版本都可以在ACM Fortran论坛站点上找到。

[http://dl.acm.org/citation.cfm?id=J286](http://dl.acm.org/citation.cfm?id=J286)

N2127已于2017年8月版中发布，而N2145可在2018年4月版中找到。

表3.2总结了Fortran标准化历史记录。

目前，Fortran 2018计划于2018年发布。

![图片](https://uploader.shimo.im/f/Db0QHEizc0AWBLco.png!thumbnail)

## 3.17 Fortran讨论列表
首先要看的是Fortran 90列表。 可以在下面找到详细信息

[http://www.jiscmail.ac.uk/lists/COMP-FORTRAN-90.html](http://www.jiscmail.ac.uk/lists/COMP-FORTRAN-90.html)

如果您订阅，则可以访问参与Fortran标准化的人员，大多数硬件和软件平台的语言实现者，在许多非常专业的领域中使用Fortran的人员，教Fortran的人员等。

还可以通过USENET新闻获得comp.lang.fortran列表。 这使在Fortran各个方面具有丰富综合专业知识的全球人士都可以接触到。 总是有人会遇到您的问题或非常喜欢它的问题，并且有一个或多个解决方案。

这是维基百科的摘录。

>Usenet是全球性的分布式Internet讨论系统。它是基于通用UUCP拨号网络体系结构开发的。汤姆·特鲁斯科特（Tom Truscott）和吉姆·埃利斯（Jim Ellis）于1979年提出这个想法，该想法于1980年成立。用户可以将消息（称为文章或帖子，统称为新闻）阅读和发布到一个或多个类别（称为新闻组）。 Usenet在许多方面都类似于电子公告板系统（BBS），并且是当今广泛使用的Internet论坛的前身。 Usenet可以从表面上看是电子邮件和网络论坛之间的混合体。讨论与Web论坛和BBS一样是经过讨论的，尽管帖子按顺序存储在服务器上。
>BBS或Web论坛与Usenet之间的显着区别是缺少中央服务器和专门的管理员。 Usenet分布在不断变化的大型服务器集团中，这些服务器在所谓的新闻提要中存储和转发消息。各个用户可以从由商业Usenet提供商，其Internet服务提供商，大学，雇主或他们自己的服务器操作的本地服务器中读取消息并将消息发布到本地服务器。

另一个要考虑的是位于“ linkedin”上的Fortran小组，地址是

[https://www.linkedin.com/](https://www.linkedin.com/)

## 3.18 ACM Fortran论坛
伊恩·奇弗斯（Ian Chivers）还是Fortran论坛（Fortran的SIGPLAN特别关注出版物）的编辑，ACM出版社。 访问

[http://portal.acm.org/citation.cfm?id=J286](http://portal.acm.org/citation.cfm?id=J286)

获得更多信息。

## 3.19 其他来源
以下网址非常有用：

我们的Fortran网站。

[https://www.fortranplus.co.uk](https://www.fortranplus.co.uk)

由Walt Brainerd维护的Fortran公司。

[http://www.fortran.com/](http://www.fortran.com/)

## 3.20 总结
希望您现在对编程语言的广泛用途有所了解。

# 第四章 编程概论
**目的**

本章的目的是：

* 引入这样的想法，即计算机可以解决很多问题，此外，要解决的问题的种类与所使用的编程语言的选择之间存在联系。
* 给出选择Fortran的一些原因。
* 介绍在通用编程语言中可以找到的基本组成部分或各种语句。
* 介绍名称，类型和值的三个概念。
* 为了以基于五个内在数据类型中的三个的示例程序说明上述内容：
* 字符，整数和实数。
* 介绍Fortran的一些正式语法规则。
## 4.1 介绍
我们已经看到，算法是解决问题的一部分或全部的一系列步骤。 程序是一种用编程语言实现的算法，乍一看，数量众多的编程语言令人惊讶。 这样做的原因是，使用计算机可以解决各种各样的问题，例如，电话公司生成分项账单或气象中心生成天气预报。 这两个问题对编程语言提出了不同的要求，并且不太可能使用相同的语言来解决这两种问题。

因此，您要解决的问题范围将极大地影响您对编程语言的选择。 Fortran代表FORmula TRANslation，它暗示了适合的预期问题范围。

## 4.2 语言优势和劣势
选择Fortran的一些原因是：

* 它是一种现代表达语言；
* 该语言适用于各种数字和非数字问题；
* 该语言可在各种硬件和操作系统平台上广泛使用；
* 已经存在许多用Fortran编写的软件。 据估计，全球约有15％的代码在Fortran中。

但是，有一些疣。 鉴于必须与早期版本具有向后兼容性，至少可以说某些语法很笨拙。 但是，如果坚持一种语言的子集并采用一致的样式，那么现在可以很干净地解决很多问题。

## 4.3 编程语言的要素
与普通的（所谓的自然）语言，例如英语，法语，盖尔语，德语等一样，编程语言也具有语法，语法和拼写规则。这些规则在编程语言中的应用更加严格。程序必须是明确的，因为它是要采取的措施的精确说明。很多日常活动的定义都比较模糊-在回家的路上买些面包-但是我们通常有足够的适应能力来应对由此产生的变化。如果在一个计算工资的程序中，我们有一条指令要扣除一些税金和保险金，那么当该程序每次运行相同的工作量时，它为同一个人计算出完全不同的工资时，我们可能会遇到一个尴尬的问题。编程语言的严格语法对新手的影响之一是，当一个人第一次开始编写程序时，显然会出现愚蠢的错误消息。与许多其他新主题一样，您必须学习一些专业术语才能理解这些信息。

编程语言由语句组成。我们将在下面简要介绍各种语句。

### 4.3.1 数据描述语句
这些对于描述要处理的数据类型是必需的。 例如，在工资计划中，人们的姓名和他们赚的钱数量之间显然存在差异，即，这两件事并不相同，并且在工资中加上姓名也没有任何意义。 术语的技术术语是数据类型-工资与姓氏（字符序列）具有不同的数据类型（数字）。

### 4.3.2 控制结构
程序可以看作是解决特定问题的语句序列，通常发现在实践中需要改变该序列。 再次考虑工资程序。 它需要在各种情况下进行选择（例如已婚或单身，每周或每月支付，等等），并且还需要为每个受雇的人重复该计划。 因此，在编程语言中需要语句改变和/或重复语句序列。

### 4.3.3 数据处理语句
在编程语言中，必须能够处理数据。 所需的处理类型将取决于数据的类型或类型。 例如，在工资程序中，您将需要区分姓名和工资。 因此，必须有不同类型的语句来操纵不同类型的数据，即工资和姓名。

### 4.3.4 输入和输出(I/O)语句
为了提高灵活性，通常会编写程序，以便它们可以使用的数据存在于程序外部。 在工资示例中，每个受雇人员的详细信息都将存储在某个位置的文件中，并且该文件中将包含每个人的记录。 这意味着，尽管个人记录可能会更新，但每次离开一个人，生病等等时，都不必修改该程序。 修改数据比修改程序更容易，并且产生意外结果的可能性较小。 为了能够改变动作，在编程语言中必须有某种机制来使数据进出程序。 这是使用输入和输出语句完成的，有时也简称为I/O语句。

## 4.4 示例1：简单文本I/O
现在让我们考虑一个简单的程序，该程序将以某人的名字读取并打印出来：

program ch0401!! This program reads in and prints out a name!implicit nonecharacter *20 :: first_nameprint *, ' type in your first name.'print *, ' up to 20 characters'read *, first_nameprint *, first_nameend program ch0401这里有几个非常重要的要点，将依次介绍：

* 每行都是一条语句。
* 语句有序列。这些语句将按照它们出现的顺序进行处理，因此在此示例中，顺序为打印，读取，打印。
* 第一条语句为程序命名。选择一个可以传达程序目的的名称是很有意义的。
* 接下来的三行是注释语句。它们用！标识。注释插入到程序中以解释程序的目的。它们应被视为所有程序的组成部分。必须养成立即在程序中插入注释的习惯。
* 隐式none语句意味着必须对程序中使用的每个数据项进行显式键入。在您编写的每个程序中都包含此语句是一种很好的编程习惯，因为它会捕获许多错误，有些错误的影响通常很小。用一个类比的剧本，在剧本的正文之前总是有一个涉及角色的清单，我们可以说该陈述具有相同的目的。
* character * 20语句是类型声明。前面提到过，存在不同类型的数据。必须有某种方式告诉编程语言，这些数据是某种类型的，因此允许某些类型的操作，而其他类型的操作则被禁止或仅仅是愚蠢的操作！在数字上添加名称是没有意义的，例如Fred + 10是什么意思？因此，该语句定义变量first_name将为character类型，并且仅允许进行字符操作。下一节将介绍变量的概念。此类型的字符变量最多可容纳20个字符。
* 打印语句在屏幕上打印出一条信息性消息-在这种情况下，它是有关键入内容的指南。强烈建议在整个程序中使用此类信息性消息。
* read语句是I / O语句之一。这是从终端或键盘读取的指令；从键盘键入的任何内容最终都将与变量first_name关联。输入/输出语句将在后面的部分中更详细地说明。
* print语句是另一个I / O语句。该语句将打印出与变量first_name关联的内容，以及在此情况下键入的内容。
* end program语句终止该程序。可以认为它类似于自然语言中的句号，因为它以句点（。）结束句子的方式完成程序。请注意在程序开始时使用program语句中给出的名称。
* 还请注意在三种不同情况下星号的使用。
* 缩进已用于使程序的结构更易于确定。程序必须被人类阅读，我们稍后将对此进行更深入的研究。
* 最后，当您运行该程序时，字符输入将以第一个空白字符终止。

上面的程序说明了Fortran语言中某些语句的用法。让我们更详细地考虑read *语句的操作-特别是变量和值的含义。

## 4.5 变量-名称，类型和值
变量的概念是您可能在数学上下文中可能遇到的。 考虑以下：

circumf erence = 2πr

这是计算圆周长的公式。 以下内容将其翻译成Fortran：

circumference = 2 * pi * radius关于此方程式，有很多事情要注意：

* 等号右侧的每个变量（pi和半径）将具有一个值，该值将允许对表达式进行求值。
* 对表达式进行完全求值时，会将值分配给等号左侧的变量。
* 在数学中隐含乘法。 在Fortran中，我们必须使用*运算符来表示我们想要将2乘以pi乘以半径。
* 我们无法访问Fortran中的π等数学符号，但必须使用基于罗马字母的变量名。

![图片](https://uploader.shimo.im/f/fGCDRA6lElPA44Di.png!thumbnail)

整行是Fortran中算术赋值语句的示例。

以下算术赋值语句清楚地说明了名称和值的概念，以及数学和计算中等号的区别：

i = i +1

在Fortran中，这将读取变量i的当前值并将其添加一个，将新值存储回变量i中，即i取值i + 1。 从代数上讲，i = i + 1没有任何意义。

变量可以是不同的类型。 表4.1列出了Fortran中可用的一些。

注意使用下划线使变量名称更易于阅读。

首先，数据类型的概念似乎有些奇怪，尤其是当我们通常将整数和实数视为数字时。 但是，从这种区别中获得的好处是可观的。 在编写了几个程序之后，这一点将变得显而易见。

## 4.6 示例2：简单的数字I/O和算术
现在让我们考虑另一个程序，该程序读取三个数字，将它们加起来并打印出总数和平均值：

program ch0402!! This program reads in three numbers and sums! and averages them!implicit nonereal :: n1, n2, n3, average = 0.0, total = 0.0integer :: n = 3print *, ' type in three numbers.'print *, ' Separated by spaces or commas'read *, n1, n2, n3total = n1 + n2 + n3average = total/nprint *, 'Total of numbers is ', totalprint *, 'Average of the numbers is ', averageend program ch0402以下是有关此程序的一些关键点。

* 该程序具有数字变量的声明，并且Fortran（与大多数编程语言相同）在实数和整数数据类型之间进行区分。
* 在类型声明中，变量average，total和n也被赋予了初始值。
* 变量最初在Fortran中是未定义的，因此变量n1，n2，n3属于此类，因为在声明它们时尚未给它们赋值。
* 第一个打印语句使屏幕上出现一条文本消息（在这种情况下，两个撇号之间是什么）。如前所述，良好的做法是发布这样的消息，以便您对应该输入的内容有所了解。
* read语句查看键盘输入（即您键入的内容），在这种情况下，将这些值与三个变量相关联。这些值可以用逗号（，），空格（）或什至通过按回车键来分隔，即它们可以出现在单独的行上。
* 下一条语句实际上进行了一些数据处理。它将三个变量（n1，n2和n3）的值相加，并将结果分配给变量total。该语句称为算术赋值语句。并将在下一章中更全面地介绍。
* 下一条语句是另一个数据处理语句。它计算输入数字的平均值，并将结果分配给平均值。我们实际上可以在这里使用值3，即写平均值= total / 3并具有完全相同的效果。这也可以避免n的类型声明。但是，原始示例遵循已建立的编程实践，即声明所有变量并明确确定其含义。在整本书中，我们将看到更多此类示例。
* 缩进已用于使程序的结构更易于确定。
* 总和和平均值以适当的标题或标题打印出来。不要在未加标题的情况下编写程序。这样做很容易出错，甚至忘记每个数字的含义。
* 最后，我们结束了程序，然后再次在program语句中使用了名称。
## 4.7 其他一些Fortran规则
有关Fortran的某些事情，除了历史上的先例以外，没有什么直接的意义，而有些根本没有逻辑上的依据。 为什么猫叫猫？ 必要时，将在几章末尾简要介绍这些规则或规定。 这里有一些：

* 源是免自由格式
* 允许使用小写字母，但不要求识别它们
* 多个语句可能出现在一行上，并用分号字符分隔
* Fortran中的语句有一个顺序。在到目前为止所涉及的范围内，该顺序为：
  * 程序声明
  * 类型声明，例如隐式，整数，实数或字符
  * 处理和I / O语句
  * 结束程序语句
* 注释可能出现在程序中，程序之后和结束之前的任何位置；他们介绍了！字符，并且可以排成一行
* 名称的长度最多为63个字符，并且包括下划线字符
* 每行最多可以包含132个字符
* 最多允许39条延续行（使用＆符作为延续字符）
* 在这些示例中引入的read和print语句的语法为:
  * 读取格式，输入项列表
  * 打印格式，输出项目列表
    * 在示例中，格式为*，称为列表定向格式。而input-item-list是由逗号分隔的变量名列表。而output-item-list是变量名和/或用“或”括起来的字符序列的列表，再次用逗号分隔。
* 如果不使用隐式none语句，则如果变量名称的首字母为A–H或O–Z，则未明确声明的变量将默认为real；如果变量名称的首字母为I，则默认为整数I–N。
## 4.8 Fortran字符集
表4.2详细介绍了Fortran字符集。

默认字符类型应支持包括Fortran字符集的字符集。 通过提供非默认字符类型，处理器可以支持其他字符集。 ASCII和ISO 10646字符集中可用的字符分别由ISO / IEC 646：1991（国际参考版本）和ISO / IEC 10646-1：2000 UCS-4指定； 除标准中未指定其他非默认字符类型中可用的字符外，每种非默认字符类型中的一个字符应指定为空白字符以用作填充字符。

![图片](https://uploader.shimo.im/f/LhYcqpqRmhHmgVIs.png!thumbnail)

表4.3列出了ASCII字符集的详细信息。

如果您在美国和英国以外的地区生活和工作，则编程时可能会遇到键盘问题。 Wikipedia上的键盘上有一个非常好的条目，对于好奇的人来说值得一看。

![图片](https://uploader.shimo.im/f/JSSlEdb3TKwjFmhA.png!thumbnail)

![图片](https://uploader.shimo.im/f/3VbomM3aNukRxYQt.png!thumbnail)

## 4.9 良好的编程准则
以下是准则，并不构成Fortran语言定义的一部分：

* 使用注释来阐明程序和整个程序的目的。
* 在程序中选择有意义的名称。
* 使用缩进突出显示程序的结构。 请记住，人和计算机都必须阅读并理解该程序。
* 在编写的所有程序中使用隐式无，以最大程度地减少错误。
* 不要依赖规则进行显式键入，因为这是编程错误的主要来源。
## 4.10 使用的编译器
在编写本书和更早的书籍时，已经使用了许多硬件平台，操作系统和编译器。 在本书的该版本的生产中使用了以下内容：

* 适用于Windows的NAG Fortran Builder 6.1和6.2
* Windows版NAG Fortran编译器6.1和6.2
* 适用于Linux的NAG Fortran编译器6.1和6.2
* Windows版Intel Fortran 16.x，17.x，18.x
* 适用于Linux的Intel Fortran 16.x，18.x
* 适用于Windows的gnu gfortran 4.8.x，4.9.x，4.10.x，5.4.x，7.x，8.0.x
* gnu gfortran 4.8.x，适用于Linux的6.3.x
* Cray Fortran：版本8.x.x-Cray Archer服务
* 适用于Linux的Oracle Solaris Studio 12.6

我们的建议是在代码开发中至少使用两个编译器。 在编译器和平台之间移动代码对您有很多帮助。

在本书第三版的制作中使用了以下内容：

* 适用于Windows的NAG Fortran Builder 6.0
* 用于Windows的NAG Fortran编译器6.0
* 适用于Linux的NAG Fortran编译器6.0
* 适用于Windows的NAG Fortran Builder 5.3.1
* 用于Windows的Nag Fortran编译器5.3.1和5.3.2
* Windows版Intel Fortran 14.x，15.x
* 适用于Linux的Intel Fortran15.x
* Windows版gnu gfortran 4.8.x，4.9.x，4.10.x
* 适用于Linux的gnu gfortran4.8.x
* Cray Fortran：版本8.2.1-Cray Archer服务
* 适用于Linux的Oracle Solaris Studio 12.4

在早期版本的生产中使用了以下内容:

* 适用于Windows的NAG Fortran Builder 5.1、5.2、5.3
* 适用于Linux的NAG Fortran编译器5.1、5.2、5.3
* Windows版的Intel Fortran 11.x，12.x，13.x
* 适用于Linux的Intel Fortran12.x
* Windows版gnu gfortran4.x
* 适用于Linux的gnu gfortran4.x
* Cray Fortran：版本7.3.1-Cray Hector服务
* Linux的g95
* pgi 10.x-Cray Hector服务
* 用于AIX的IBM XL Fortran，V13.1（5724-X15），版本：13.01.0000.0002
* 适用于Linux的Oracle Solaris Studio 12.0、12.1和12.2

以下已用于早期书籍：

* VMS下的DEC VAX，以及后来使用NAG Fortran 90编译器的OPEN VMS
* 使用DEC Fortran 90编译器的OPEN VMS下的DEC Alpha
* Solaris下的Sun Ultra Sparc：
  * NAGACE F90编译器
  * NAGWare F95编译器
  * Sun（Release 1.x）F90编译器
  * Sun（Release 2.x）F90编译器
* DOS和Windows下的PC：
  * DEC / Compaq Fortran 90和Fortran 95编译器
  * 英特尔编译器（7.x，8.x）
  * Lahey Fujitsu Fortran 95（5.7）
  * NAG Fortran 95编译器
  * NAG Salford Fortran 90编译器
  * Salford Fortran 95编译器
* Linux下的PC：
  * 英特尔编译器
  * Lahey Fujitsu Fortran 95 Pro（6.1）
  * NAG Fortran 95（4.x，5.x）

在开发程序时使用多个编译器非常具有启发性。

## 4.11 编译器文档
编译器可能随附文档。 以下是一些编译器的一些详细信息。

### 4.11.1 gfortran
手册可在

[http://gcc.gnu.org/wiki/GFortran\#manuals](http://gcc.gnu.org/wiki/GFortran\#manuals)

以下

[http://gcc.gnu.org/onlinedocs/gcc-4.5.2/gfortran.pdf](http://gcc.gnu.org/onlinedocs/gcc-4.5.2/gfortran.pdf)

是236页的pdf。

### 4.11.2 IBM
这是一个起点。 由于行太长，URL已被分割:

[http://www-03.ibm.com/software/products/en/fortcompfami/](http://www-03.ibm.com/software/products/en/fortcompfami/)

这是XLF for AIX系统的起点:

[http://www-01.ibm.com/support/docview.wss?uid=swg27036673](http://www-01.ibm.com/support/docview.wss?uid=swg27036673)

并且该文档的pdf版本的起点是:

[http://www-01.ibm.com/support/docview.wss?uid=swg27036673](http://www-01.ibm.com/support/docview.wss?uid=swg27036673)

他们提供

* XL Fortran for AIX 15.1入门书向您介绍XL Fortran for Linux及其功能，包括15.1的新增功能。
* 安装指南-用于AIX 15.1的XL Fortran本书包含有关安装XL Fortran以及配置环境以进行基本编译和程序执行的信息。
* 编译器参考-适用于AIX 15.1的XL Fortran本书包含有关许多XL Fortran编译器选项和环境变量的信息，可用于根据应用程序开发需求定制XL Fortran编译器。
* 语言参考-适用于AIX 15.1的XL Fortran本书包含IBM支持的有关Fortran编程语言的信息，包括有关可移植性和符合非专有标准的语言扩展，编译器指令和内部过程。
* 优化和编程指南-用于AIX 15.1的XL Fortran本书包含有关高级编程主题的信息，例如应用程序移植，语言间调用，浮点操作，输入/输出，应用程序优化和并行化以及XL Fortran高性能库。
### 4.11.3 Inter
Windows完整安装后，以下内容将可用。

* 英特尔MKL
  * 发行说明
  * 参考手册
  * 用户指南
* 并行调试器扩展
  * 发行说明
* 编译器
  * 参考手册，Visual Studio帮助文件或html
  * 用户指南，Visual Studio帮助文件或html

英特尔还提供以下服务

[https://software.intel.com/en-us/articles/intel-software-technical-documentation/](https://software.intel.com/en-us/articles/intel-software-technical-documentation/)

### 4.11.4 Nag
Windows 

* Fortran Builder帮助
  * Fortran Builder教程-44页
  * Fortran Builder操作指南-67页
  * Fortran语言指南-115页
  * 编译器手册-149页
  * LAPACK指南-70页（440MB为PDF！）
  * GTK +库-201页
  * OpenGL / GLUT库-38页
  * SIMDEM库-78页
### 4.11.5 Oracle/Sun
Oracle提供了一系列文档。 从Oracle Solaris Studio内部

* 帮助
  * 帮助内容
  * 在线文档和支持
  *  ..
  *  ..
  * 快速入门指南

并且其中的一些条目将带您进入Oracle站点。

您也可以下载300 MB以上的zip文件，其中包含大量的Oracle文档。 您应该能够找到（经过四处翻找）

* Sun Studio 12：Fortran编程指南-174页
* Sun Studio 12：Fortran用户指南-216页
* Sun Studio 12：Fortran库参考-144页
* Fortran 95间隔算术编程参考-166页

Happy reading :-)

## 4.12 程序开发
已经使用了许多开发程序的方法，包括：

* 使用集成开发环境，包括
  * Windows下的NAG Fortran Builder
  * Windows下具有Intel编译器的Microsoft Visual Studio
  * SuSe Linux下的Oracle Sunstudio
* 在Windows下使用DOS框和简单命令行提示符
* 使用ssh登录到Archer服务
* 使用VPN和SSH登录到斯洛伐克水文气象研究所Jeseniova 17的IBM Power 7系统
* 在SuSe Linux下使用控制台或终端窗口
* 使用X-Windows软件登录SUN Ultra Sparc系统
* 使用终端仿真软件登录到SUN Ultra Sparc
* 使用DEC终端登录DEC VAX和DEC Alpha系统
* 使用运行终端仿真软件的PC登录DEC VAX和DEC Alpha系统

您可能最终会完成上述至少一项，甚至可能更多。

涉及的关键阶段是：

* 创建并更改Fortran程序源
* 保存文件
* 编译程序：
* 如果存在错误，则必须返回Fortran源并进行编译器错误消息指示的更改
* 如果成功生成可执行文件则进行链接：
* 自动链接。这发生在幕后，并且会立即为您生成可执行文件
* 手动链接。您显式调用链接器以生成可执行文件
* 运行程序
* 确定程序是否真正起作用并给出预期结果

无论您使用的硬件平台，操作系统和编译器如何，都必须执行这些步骤。有些人喜欢在操作系统提示符下工作（例如DOS，Linux和UNIX），而另一些人则喜欢在开发环境中工作。两者都有优点和缺点。

## 4.13 问题
4.1 编译并运行本章中的示例1。试用以下类型的输入。

伊恩

伊恩·奇弗斯（Ian Chivers）

“简·玛格丽特·斯莱特霍姆”

4.2 编译并运行本章中的示例2。

考虑以下几点：

* 用空格或逗号分隔输入之间有区别吗？
* 您是否需要小数点？
* 输入太多数据会怎样？
* 输入的数据太少会怎样？

如果您可以使用多个编译器，请重复上述步骤并比较结果。

4.3 编写一个程序，该程序将读取您的姓名和地址，并以相反的顺序打印出来。

考虑以下几点：

* 您的姓名和地址有几行？
* 您的姓名和地址最长的一行中最多可以包含多少个字符？
* 在每个输入行的第一个空白字符处会发生什么？
* 在Fortran中可以使用哪些字符来包围键入的文本的每一行，从而不止于第一个空白字符？
* 如果使用两个特殊字符之一来括住文本，如果您从一行开始，然后在终止文本之前按回车键，会发生什么情况？

在Fortran实现之间，此处的操作将有所不同。

# 第五章 算法
**目的**

本章的目的是介绍：

* 用于计算算术表达式的Fortran规则，以确保按预期对它们进行求值；
* 截断和舍入的概念；
* 使用parameter属性定义或设置常量；
* 使用Fortran的种类类型来确定和控制执行Fortran中算术的精度；
* 用于整数和实数算术的数值模型和位置数字系统的概念，以及它们在二进制设备上的实现。
* 在系统上测试不同整数类型类型的数字表示形式– 8、16、32和64位整数
* 在系统上测试不同实类型的数字表示形式– 32、64、80和128位实数
*  四舍五入
* 相对误差
* 绝对误差
## 5.1 介绍
学术界和科学界中的大多数问题都需要算术评估作为算法的一部分。 计算机执行的算术与您在常规数学和代数中熟悉的算术不同。

我们需要解决两个领域

* 涉及有限精度的计算-称为计算机算术
* 适用于编程语言的规则-不同的编程语言具有不同的表达式计算规则

以上结果意味着使用计算机时2 + 2不一定是4！

## 5.2 Fortran运算符和算术赋值语句
在上一章中，我们介绍了算术赋值语句，强调了名称，类型和值的概念。 在这里，我们将考虑在Fortran中计算算术表达式的方式。

表5.1列出了Fortran中可用的五个算术运算符。

![图片](https://uploader.shimo.im/f/SBsdM3Ytx0MAVbu3.png!thumbnail)

幂运算使幂数增加。 请注意，幂运算符是两次*。

以下是Fortran中有效算术赋值语句的一些示例：

taxable_income = gross_wage - personal_allowancecost = bill + vat + servicedelta = deltax/deltayarea = pi * radius * radiuscube = big ** 3这些表达式都很简单，并且在评估它们时没有问题。 但是，现在考虑以下几点：

tax = gross_wage - personal_allowance * tax_rate这是一个写得不好的算术表达式。 可以选择在乘法之前或之后进行减法。 我们的日常经验表明，减法应该在乘法之前进行。 但是，如果在Fortran中对该表达式求值，则乘法将在减法之前完成。

## 5.3 示例1：Fortran中的简单算术表达式
在Fortran中显示正确格式的完整程序如下：

program ch0501implicit none!! Example of a Fortran program! to calculate net pay! given an employee's gross pay!! The UK personal allowance is! correct as of 2014!real :: gross_wage, net_wage, taxreal :: tax_rate = 0.25integer :: personal_allowance = 10000character (len=60) :: their_nameprint *, 'Input employees name'read *, their_nameprint *, 'Input Gross wage'read *, gross_wagetax = (gross_wage-personal_allowance)*tax_ratenet_wage = gross_wage - taxprint *, 'Employee: ', their_nameprint *, 'Gross Pay: ', gross_wageprint *, 'Tax: ', taxprint *, 'Net Pay:', net_wageend program ch0501让我们看一下该程序的一些关键点。

* 我们有隐式的none语句，可帮助检测键入错误。
* 我们声明变量Gross_wage，net_wage，tax和tax_rate为实数类型，因为它们将保存浮点值，即带小数点的数字。
* 变量them_name的类型为character，最多可容纳60个字符。
* 变量personal_allowance的类型为integer，因为它保存整数值。
* 然后，我们有一些I / O语句提示用户输入内容，并阅读他们的姓名和总工资。
* 然后，我们使用两个简单的算术赋值语句计算应纳税额和净收入。
* 然后我们打印出结果。

此示例说明了Fortran中的一些基本算法。

## 5.4 Fortran算术规则
我们需要在这里看三个方面：

* 构成表达式的规则-语法
* 解释表达式的规则-语义
* 评估表达式的规则-优化

语法规则确定哪些表达式有效。语义确定有效的解释，一旦完成，编译器就可以用数学上等效的任何其他表达式替换该表达式，通常是出于优化的考虑。

这是Fortran 2018标准中有关表达式评估的部分。

* 10.1.5.2.4数值内在运算的评估
  * 1禁止执行其结果未由处理器使用的算术定义的任何数字运算。禁止将负实数值提高为有功功率。
  * 2一旦建立了数值内在运算的解释，只要不违反括号的完整性，处理器就可以计算任何数学上等价的表达式。
  * 3如果数值类型的两个表达式的基数的所有可能值相等，则它们的数学值相等。但是，数值类型的数学等价表达式可能会产生不同的计算结果。

在Fortran中评估表达式的规则如下：

* 方括号用于定义表达式求值的优先级。
* 运算符具有优先级-优先级。运算符的层次结构为：
* 指数：当表达式具有多个指数时，计算从右到左。例如，

l = i ** j ** k

首先将j提升至幂k，然后将该结果用作i的指数来进行评估；更明确地说，

l = i **（j ** k）

尽管这与我们期望对代数表达式进行求值的方式相似，但它与乘法和除法规则不一致，并可能导致混淆。如有疑问，请使用方括号。

* 乘法和除法：在连续的乘法和除法中，关于任何数学等效表达式的规则意味着您必须使用方括号来确保所需的求值。例如，

a = b * c / d * e

对于实数和复数类型，编译器不必以从左到右的方式求值，即求b乘c，然后将结果除以d，最后取该结果并乘以e。

* 加法和减法：对于乘法和除法，适用于任何等效表达式的规则。但是，除非涉及其他运算符，否则很少有加和减的顺序很重要。

表5.2总结了运算符的层次结构。

![图片](https://uploader.shimo.im/f/lXJJNlJWDRwtv5cj.png!thumbnail)

以下是Fortran中有效算术表达式的所有示例：

slope = (y1-y2)/(x1-x2)x1 = (-b+((b*b-4*a*c)**0.5))/(2*a)q = mass_d/2*(mass_a*veloc_a/mass_d)**2 + &((mass_a * veloc_a)**2)/2请注意，已使用方括号使评估顺序更加明显。 通常可以在不带括号的情况下编写所涉及的表达式，但是为了清楚起见，最好最好将括号留在里面，甚至要插入一些额外的括号以确保正确评估表达式。 用括号将表达式的运算与不使用括号一样快速。 还要注意，所有表达式都不是特别复杂。 最后一个问题与您应该尝试的一样复杂：比这复杂的事情多，很容易出错。

## 5.5 等效表达
关于任何等效表达式的规则意味着，如果a，b和c是数字，则以下条件成立：

a + b = b + a- a + b = b - aa + b + c = a + (b + c)名义上，最后一个从左到右进行评估，因为添加项的优先级相同：

a * b = b * aa * b * c = a * (b * c)再次对最后一个进行名义上的从左到右的求值，因为乘法的优先级相同：

a * b - a * c = a * (b - c)a / b / c = a / (b * c)最后一个仅适用于实数和复数类型。

当错误表达式产生的值在期望值的范围内并且错误很可能无法检测到时，就会出现问题。 乍一看可能很奇怪，但是计算机完全按照指令执行操作。 如果通过程序员的某种误解，从问题定义的角度来看，该程序在语法上是正确的，但是在逻辑上是错误的，那么编译器将不会发现这一点。 如果表达式很复杂，请将其分解为连续的语句，并在每行上包含该表达式的元素，例如，

temp = b * b - 4 * a * cx1 = ( - b + ( temp ** 0.5 )) / ( 2 * a )和：

## Moment = Mass_A * Veloc_AQ = Mass_D / 2 * ( Moment / Mass_D ) **2 + &( Moment **2) / 25.6 舍入和截断
计算机算术可能会被截断和舍入。

* 截断。 此操作涉及扔掉部分数字，例如14.6将数字截断为两个数字的叶子14。
* 四舍五入。 再次考虑14.6。 这将四舍五入为15。基本上，该数字将更改为最接近的整数。 它仍然是一个实数。 您认为14.5将会发生什么？ 会四舍五入吗？

您必须注意这两个操作。它们有时会在除法和具有多个数据类型的表达式中引起问题。

## 5.7 示例2：类型转换和赋值
要查看可能发生的一些问题，请考虑以下示例：

program ch0502implicit nonereal :: a, b, cinteger :: ia = 1.5b = 2.0c = a/bi = a/bprint *, a, bprint *, cprint *, iend program ch0502执行这些语句后，c的值为0.75，而我的值为零！ 这是一个在=号上进行类型转换的示例。 右边的变量都是实数，但左边的最后一个变量是整数。 因此，该值将被截断为整数。 在此示例中，0.75为实数，因此当截断发生时我变为零。

## 5.8 示例3：整数除法和实分配
现在考虑一个示例，在该示例中，我们将一个赋值给一个实变量（因此不会由于赋值而导致截断），但是右侧表达式的一部分涉及整数除法：

program ch0503implicit noneinteger :: i, j, kreal :: answeri = 5j = 2k = 4answer = i/j*kprint *, iprint *, jprint *, kprint *, answerend program ch0503answer的值为8，因为i / j项涉及整数除法。 预期的10答案与实际的8答案没有什么不同，正是这种情况给粗心的人造成了问题，即计算结果可能接近实际的答案。 在复杂的表达式中，很容易错过这样的东西。

回顾一下，截断在Fortran中发生：

* 当将实数分配给整数时，在=符号上
* 整数除法

尝试混合模式算术时（即，将实数和整数混合时）请务必小心。 如果一个实数和一个整数相除或相乘，则该运算的结果将为实数；否则，该结果将为实数。 当在类似情况下进行加减运算时，结果也将是真实的。 当使用整数算术运算表达式的某些部分而使用实数算术计算表达式的某些部分时，就会出现问题：

c = a + b - i / j

整数除法是在加法和减法之前执行的； 因此，尽管表达式的所有其他部分都将使用实数算法执行，但i / j的结果是整数。

## 5.9 示例4：光从太阳到地球传播所花费的时间
光从太阳到达地球需要多长时间？ 光线在1年内传播9.46 10 ^ 12 km。 我们可以将一年等于365.25天。 （所有学童都知道，天文年是365天，5小时，48分钟和45.9747 s-几乎不值得付出额外的努力。）地球与太阳之间的距离约为1.5亿公里。 这些数字显然存在一些不精确之处，尤其是因为地球是在椭圆轨道而不是圆形轨道上运动。 在介绍程序之前要注意的最后一点是经过的时间将以分钟和秒为单位。 很少有人会轻易掌握一年的零头部分：

program ch0504implicit nonereal :: light_minute, distance, elapseinteger :: minute, secondreal, parameter :: light_year = 9.46*10**12! Light_year : Distance travelled by light! in one year in km! Light_minute : Distance travelled by light! in one minute in km! Distance : Distance from sun to earth in! km! Elapse : Time taken to travel a! distance (Distance) in minutes! Minute : integer number part of elapse! Second : integer number of seconds! equivalent to fractional! part of elapse!light_minute = light_year/(365.25*24.0*60.0)distance = 150.0*10**6elapse = distance/light_minuteminute = elapsesecond = (elapse-minute)*60print *, ' Light takes ', minute, ' Minutes'print *, ' ', second, ' Seconds'print *, ' To reach the earth from the sun'end program ch0504计算很简单； 首先，我们计算光在1分钟内的传播距离，然后使用该值来计算光在一定距离内传播需要多少分钟。 通过利用Fortran在类型转换时将实数截断为整数的方式，可以将以分钟为单位的时间分为整数分钟和秒。 这两个值之间的差异是分钟的一部分，需要将其转换为秒。 考虑到练习中已经固有的误差，给小数点后的秒似乎没有意义。

值得注意的是，通过使用注释行将程序的各个部分分成相当不同的块，已经尝试了某些结构。还请注意，注释行描述了程序中使用的变量。

您看到此示例有任何问题吗？

## 5.10 参数属性
此属性用于提供一种将有意义的名称与程序中的常量相关联的方式。 考虑一个将大量使用π的程序。 每次都要输入3.14159265358是很愚蠢的。 输入的内容很多，输入正确的值可能会出错。 因此，一次设置pi，然后按名称引用它是有意义的。 但是，如果pi只是一个变量，则可以执行以下操作：

real :: li,pi.pi=4.0*atan(1.0).pi=4*alpha/beta.pi = 4 * alpha / beta语句应为li = 4 * alpha / beta。 发生的事情是，由于键入错误（p和l在键盘上靠得很近），错误逐渐蔓延到程序中。 编译器不会发现它。 Fortran提供了一种在这里帮助处理参数属性的方法，该属性应该添加到类型声明中或与类型声明结合使用。

表5.3详细列出了一些常用的物理常数。

![图片](https://uploader.shimo.im/f/qXYmvqqM3EAnBsBH.png!thumbnail)

数据取自

[http://physics.nist.gov/cuu/index.html](http://physics.nist.gov/cuu/index.html)

具有参数属性的类型语句可以包含算术表达式，因此可以在设置这些常量时执行一些相对简单的算术。 评估必须限于加法，减法，乘法，除法和整数幂运算。

以下是一些物理常数的parameter属性的一些示例。

real , parameter :: pi = &4.0*atan(1.0)real , parameter :: c = &299792458 * 10.0 ** (-1)real , parameter :: e = &1.602176565 * 10.0 ** (-19)在本示例中，我们介绍了Fortran内在函数atan，有关更多详细信息，请参见附录D。我们还将在下一章中介绍内在函数。 parameter属性的优点是您不能再为pi，c或charge分配另一个值。 如果尝试这样做，编译器将生成一条错误消息。

## 5.11 舍入错误和计算机算法
精度与精度不同。 在这个数字计时时代，很容易为这个问题提供一个非常精确的答案。 即使被报告到十分之一秒（甚至百分之一！），该答案也不一定是准确的。 不要愚蠢地认为报告为十进制小数位的答案必须精确到十进制小数位。 计算机只能保留有限的精度。 当执行计算时，此限制将趋于在结果中产生误差。 这种不准确度的估计是称为“数值分析”的数学分支的领域。

为了对问题有一些了解，请考虑一个假想的十进制计算机，该计算机在计算中保留两个有效数字。 例如，将1.2、12.0、120.0和0.12都赋予两位数的精度。 因此请注意，在该设备中1234.5将表示为1200.0。 当执行任何算术运算时，结果（包括任何中间计算）将具有两个有效数字。 从而：

130 + 12 = 140 (rounding down from 142)并类似地：

17 / 3 = 5.7 (rounding up from 5.666666...)和：

16 * 16 = 260在涉及更多计算的情况下，结果可能变得不那么有吸引力。 假设我们希望评估

(16 * 16) / 0.14我们希望得到1828.5718或两个有效数字1800.0的答案。 如果我们首先评估方括号内的字词，则答案为260 / 0.14或1857.1428； 在两位数机器上为1900.0。 认为我们可以做得更好，因此可以将分数改写为

(16 / 0.14) * 16结果为1800.0。

代数表明，如果可获得无限精度，则所有这些评估都是等效的。

舍入误差（也称为舍入误差）是计算得出的数字近似值与其精确数学值之间的差。 我们将在本章后面更深入地研究这个问题。

## 5.12 相对误差和绝对误差
在计算解决方案的数值近似值时，我们经常需要测量估计的解决方案的准确性。 如果我们使用迭代方法，则可以查看连续计算之间的差异，或者我们的算法可能具有用于估计误差的表达式。

两种方式都有两种类型的错误：绝对错误和相对错误。

与绝对误差相比，查看相对误差是一种更好的测量精度的方法，因为绝对误差取决于近似数字的大小。

如果p'是p的近似值，则相对误差为| p − p' | / | p | 绝对误差为| p − p' |。

这是一个说明上述内容的示例。

## 5.13 示例5：相对误差和绝对误差
program ch0505implicit nonereal :: p = 0.4e-4, papprox = 0.41e-4real :: abs_error, rel_errorinteger :: ido i = 1, 3abs_error = abs(p-papprox)rel_error = abs(p-papprox)/abs(p)print 100, p, papprox100 format ('p = ', e11.4, /, &'papprox = ', e11.4)print 110, abs_error, rel_error110 format ('abs error:', 12x, e11.4, /, &'rel error:', 12x, e11.4, /)p = p*1.0e5papprox = papprox*1.0e5end doend program ch0505该程序引入了内在的abs函数和一个新的语句，format语句和（e）编辑描述符。 目前，只专注于输出。 在下一章中，我们将更深入地讨论format语句和（e）编辑描述符。 有关绝对内在函数的更多信息，请参见附录D。

这是Nag编译器的输出。

p = 0.4000E-04approx to p = 0.4100E-04abs error: 0.1000E-05rel error: 0.2500E-01p = 0.4000E+01approx to p = 0.4100E+01abs error: 0.1000E+00rel error: 0.2500E-01p = 0.4000E+06approx to p = 0.4100E+06abs error: 0.1000E+05rel error: 0.2500E-01此示例表明，对于变化范围很大的绝对误差，也会发生0.25 * 10 ^ −1的相同相对误差，因此，绝对误差会产生误导。

相对误差更有意义，因为它考虑了数字的大小。

## 5.14 数字的范围，精度和大小
整数的范围以及计算中浮点数的精度和大小与分配给其内部表示的位数直接相关。 表5.4和5.5汇总了用于整数和实数的两个最常见的位大小的信息，即IEEE标准中定义的32位和64位。 当今使用的大多数硬件都或多或少地支持这些标准。

我们将在后面的章节和单独的章节中介绍IEEE 754。

表5.4查看整数，表5.5查看实数。

出于实际目的，所有编译器都支持这两个表中包含的信息。

![图片](https://uploader.shimo.im/f/gp8EQ8HDTyTeI4h1.png!thumbnail)

![图片](https://uploader.shimo.im/f/ZdR7ggBitvEC3wOJ.png!thumbnail)

## 5.15 上溢和下溢
当它接近机器的数值极限时也要小心。 考虑以下：

z = b * c / d其中b，c和d均为O（10 ^ 30），我们使用32位浮点数，其中最大实数为O（10 ^ 38）。在这里乘积b *生成一个O（10 ^ 60） -超出了机器的极限。 由于数量太大，这称为溢出。 请注意，我们可以通过将其重新键入为

z = b * (c / d)括起来的表达式c / d现在将为O（10 ^ 30）/ O（10 ^ 30），并且在机器范围内。

### 5.15.1 示例6：溢出
这是说明上述内容的示例程序。

program ch0506implicit nonereal :: z = 0.0real :: b = 1.0e30real :: c = 1.0e30real :: d = 1.0e30z = b*c/dprint *, zz = b*(c/d)print *, zend program ch0506这是英特尔编译器的输出。

Infinity1.0000000E+30这是Nag编译器的输出。

nagfor ch0506.f90NAG Fortran CompilerError: ch0506.f90, line 7:Floating-point overflow in single-precisionmultiplication[NAG Fortran Compiler error termination, 1 error]因此，Nag编译器会在编译时诊断问题。

### 5.12.2 示例7：下溢
因此，Nag编译器在数字太小时会诊断为“下溢”，该问题的诊断如下：编译时间。

z = b * c * d其中b和c是O（10 ^ -30）/ O（10 ^ 30）。 b * c的中间结果是O（10 ^ -60）-再次超出了机器的极限。 通过重新输入以下内容可以解决此问题：

z = b * (c * d)这是一个说明下溢的简单程序。

program ch0507implicit nonereal :: z = 0.0real :: b = 1.0e-30real :: c = 1.0e-30real :: d = 1.0e30z = b*c*dprint *, zz = b*(c*d)print *, zend program ch0507这是使用Nag和Intel编译器运行程序的输出。

0.0000000E+001.0000000E-30我们将在IEEE算术一章中更详细地讨论下溢。

## 5.16 健康警告：可选阅读，建议初学者离开直到以后
大多数人完全把算术视为理所当然，很少考虑这个问题。 如果我们要了解计算机在该领域的工作，则需要更深入地研究它。

### 5.16.1 位置编号系统
我们处理数字的方式本质上是一种定位方式。 例如，当我们查看数字1024时，我们很少以1 * 1000 + 0 * 100 + 2 * 10 + 4 * 1的形式来考虑。因此，我们在日常生活中使用的普通十进制系统是位置数， 以10为底。

我们可能知道我们可以使用其他数字基数，而2、8和16是相当常见的备用数字基数。 由于计算机是二进制设备，因此使用基数2。

当数字变得很大或非常小时，例如，一秒差距通常表示为3.08 * 10 ** 16，而这里的尾数为3.08，指数为10，我们也相当熟悉尾数指数或浮点数组合 ** 16。

以上信息将有助于理解在计算机系统上表示整数和实数的方式。

### 5.16.2 Fortran表示模型
Fortran具有三种数据表示形式

* 钻头型号
* 整数系统模型
* 实数系统模型

这些模型（以及相应的固有函数）返回与模型相关的值。 我们在下面依次看每个。

#### 5.16.2.1 位数据类型和表示模型
该模型仅针对正整数（或基数）定义，其中将它们表示为二进制数字序列，并且基于该模型：

![图片](https://uploader.shimo.im/f/BJIxlzrJLJSR9siZ.png!thumbnail)

其中，i是整数值，n是位数，bk是0或1的位数，位数从0开始，从右到左读取。 因此，整数43和位模式101011由下式给出：

43 = (1 ∗ 32) + (0 ∗ 16) + (1 ∗ 8) + (0 ∗ 4) + (1 ∗ 2) + (1 ∗ 1)或者：

#### 43 = (1 ∗ 25) + (0 ∗ 24) + (1 ∗ 23) + (0 ∗ 22) + (1 ∗ 21) + (1 ∗ 20)5.16.2.2 整数数据类型和表示模型
整数数据类型基于模型

![图片](https://uploader.shimo.im/f/ttHtQcaiRuYZ1Mbl.png!thumbnail)

其中i是整数值，s是符号，q是位数（始终为正），r是基数或基数（整数大于1），lk是正整数（小于r）。

通常以2为底，所以1023是

#### 1023 = (1 ∗ 29) + (1 ∗ 28) + (1 ∗ 27) + (1 ∗ 26) + (1 ∗ 25) + (1 ∗ 24) + (1 ∗ 23) + (1 ∗ 22) + (1 ∗ 21) + (1 ∗ 20)5.16.2.3 实数据类型和表示模型
实数类型基于模型

![图片](https://uploader.shimo.im/f/p5b9t1d3XMRvra5A.png!thumbnail)

其中x是实数，s是符号，b是基数或基数（大于1），m是尾数的位数，e是emin到emax范围内的整数，fk是正数小于b的数字。

这意味着，例如，对于32位实数，将有8位分配给指数，有24位分配给尾数。每个部分中的一位将用于表示符号，称为符号位。这将可用于表示尾数和指数的位数分别减少到31和7。还有一个归一化的概念，其中对指数进行了调整，以使最高有效位位于位置22，这些位通常编号为0-22，而不是1-23。这种表示形式并不新鲜，最早在公元前1750年左右记录，当时巴比伦的数学家使用六进制（基数为60）的位置表示法。有趣的是，他们使用的形式省略了指数！

这是在Fortran中表示这三种数据类型的理论基础。

该信息以及以下内容为跨各种硬件编写可移植代码提供了良好的基础。

## 5.17 类型种类
Fortran 90引入了固有类型的实参的概念。 每个固有类型都有一个kind参数，该参数选择该类型和种类的对象的处理器相关表示。

每个固有类型都被分类为数字类型或非数字类型。 数值类型为整数，实数和复数。 非数字固有类型是字符和逻辑。

### 5.17.1 示例8：测试可用的种类类型
以下程序显示每种内在类型可用的种类类型。

program ch0508use iso_fortran_envprint *, ' Real kinds ', real_kindsprint *, ' Integer kinds ', integer_kindsprint *, ' Character kinds ', character_kindsprint *, ' Logical kinds ', logical_kindsend program ch0508固有模块ISO_FORTRAN_ENV提供与Fortran环境有关的公共实体。 处理器应提供子条款16.10.2中描述的命名常量，派生类型和过程。 符合Fortran 2018标准。

这是许多编译器的示例输出。 在每种情况下，数字都是指字节数。

![图片](https://uploader.shimo.im/f/CfXQutyaCyqeSGH4.png!thumbnail)

![图片](https://uploader.shimo.im/f/GXMrzXMpGpBS9yMr.png!thumbnail)

![图片](https://uploader.shimo.im/f/ePMCNk4K1TjbIC7f.png!thumbnail)

必须使用-kind = byte标志调用Nag编译器以生成上述输出。

![图片](https://uploader.shimo.im/f/oIkYM9XQ09QzZFem.png!thumbnail)

gfortran编译器支持10字节实型。 我们稍后将对此进行更深入的研究。

所有四个编译器都支持1、2、4和8字节整数类型。 gfortran编译器还支持16字节整数类型。

所有编译器都支持1字节字符类型。 gfortran还支持4字节字符类型。 Nag支持2和3字节字符类型。

所有四个编译器都支持1字节逻辑类型。 Nag还支持2、3和4字节逻辑类型。

## 5.18 测试系统上不同类型的数值表示
表5.6提供了种类查询功能的详细信息，而表5.7提供了数字查询功能的详细信息。

下一组程序将测试编译器支持的固有类型的种类。

![图片](https://uploader.shimo.im/f/Z8FIcxc57d70k7DU.png!thumbnail)

![图片](https://uploader.shimo.im/f/8zuAuLKBVCNRs1Ea.png!thumbnail)

## 5.19 示例9：使用整数类型的数字查询功能
该程序着眼于将整型内部函数与整数类型一起使用。

program ch0509implicit none! example of the use of the kind function! and the numeric inquiry functions! for integer kind types! 8 bit -128 to! 127 10**2! 16 bit -32768 to! 32767 10**4! 32 bit -2147483648 to! 2147483647 10**9! 64 bit! -9223372036854775808 to! 9223372036854775807 10**18integer :: iinteger, parameter :: i8 = selected_int_kind(2)integer, parameter :: i16 = selected_int_kind(4)integer, parameter :: i32 = selected_int_kind(9)integer, parameter :: i64 = selected_int_kind(18)integer (i8) :: i1integer (i16) :: i2integer (i32) :: i3integer (i64) :: i4print *, ' 'print *, ' integer kind support'print *, ' kind huge'print *, ' 'print *, ' ', kind(i), ' ', huge(i)print *, ' 'print *, ' ', kind(i1), ' ', huge(i1)print *, ' ', kind(i2), ' ', huge(i2)print *, ' ', kind(i3), ' ', huge(i3)print *, ' ', kind(i4), ' ', huge(i4)print *, ' 'end program ch0509在此示例中，我们为每种受支持的整数类型类型引入参数。

表5.8详细说明了我们为整数种类类型指定的名称。

![图片](https://uploader.shimo.im/f/pQ2QXFwlMP0dPuPN.png!thumbnail)

由于种类类型参数具有有关基础表示形式的一些信息。

Fortran 2018标准的16.10.2.14节包含有关这些命名常量的详细信息：

* int8
* int16
* int32
* int64

其中值对应于整数类型，其以位表示的存储大小分别为8、16、32和64。

可通过ISO_FORTRAN_ENV内部模块使用它们。

它们是在Fortran 2008标准中引入的，在撰写本书时，由于只有一个编译器支持整个Fortran 2008标准，因此在示例中将使用i8，i16，i32和i64。

表5.9详细介绍了每种整数类型。

![图片](https://uploader.shimo.im/f/HSxAx5PoevJfVBDD.png!thumbnail)

从这三个编译器的输出可以看出，它们都支持相同的4种整数类型，即8位，16位，32位和64位。

在您可以访问的任何系统上运行该程序，并将输出与以上示例进行比较。

## 5.20 示例10：对实类型使用数字查询功能
program ch0510implicit none! real arithmetic!! 32 and 64 bit reals are normally available.! The IEEE format is as described below.!! 32 bit reals 8 bit exponent, 24 bit mantissa! 64 bit reals 11 bit exponent, 53 bit mantissa!real :: rinteger, parameter :: sp = selected_real_kind( &6, 37)integer, parameter :: dp = selected_real_kind( &15, 307)integer, parameter :: qp = selected_real_kind( &30, 291)real (sp) :: rspreal (dp) :: rdpreal (qp) :: rqpprint *, ' ====================='print *, ' Real kind information'print *, ' ====================='print *, ' kind number'print *, ' ', kind(r), ' ', kind(rsp), ' ', &kind(rdp), ' ', kind(rqp)print *, ' digits details'print *, ' ', digits(r), ' ', digits(rsp), &' ', digits(rdp), ' ', digits(rqp)print *, ' epsilon details'print *, ' ', epsilon(r)print *, ' ', epsilon(rsp)print *, ' ', epsilon(rdp)print *, ' ', epsilon(rqp)print *, ' huge value'print *, ' ', huge(r)print *, ' ', huge(rsp)print *, ' ', huge(rdp)print *, ' ', huge(rqp)print *, ' maxexponent value'print *, ' ', maxexponent(r)print *, ' ', maxexponent(rsp)print *, ' ', maxexponent(rdp)print *, ' ', maxexponent(rqp)print *, ' minexponent value'print *, ' ', minexponent(r)print *, ' ', minexponent(rsp)print *, ' ', minexponent(rdp)print *, ' ', minexponent(rqp)print *, ' precision details'print *, ' ', precision(r), ' ', &precision(rsp), ' ', precision(rdp), ' ', &precision(rqp)print *, ' radix details'print *, ' ', radix(r), ' ', radix(rsp), &' ', radix(rdp), ' ', radix(rqp)print *, ' range details'print *, ' ', range(r), ' ', range(rsp), &' ', range(rdp), ' ', range(rqp)print *, ' tiny details'print *, ' ', tiny(r)print *, ' ', tiny(rsp)print *, ' ', tiny(rdp)print *, ' ', tiny(rqp)end program ch0510在上面的示例中，我们使用LAPACK95使用的命名约定，这是LAPACK的Fortran 95接口。

对于实数类型，我们有

* sp-单精度
* dp-双精度
* qp-四精度

LAPACK用Fortran 90编写，提供了用于求解联立线性方程组，方程组线性系统的最小二乘解，特征值问题和奇异值问题的例程。 还提供了相关的矩阵分解（LU，Cholesky，QR，SVD，Schur，广义Schur），以及相关的计算方法，例如对Schur分解的重新排序和估计条件数。 处理密集和带状矩阵，但不处理一般的稀疏矩阵。 在所有领域，单精度和双精度都为实数和复杂矩阵提供了类似的功能。

他们的地址是

[http://www.netlib.org/lapack95/](http://www.netlib.org/lapack95/)

Fortran 2008标准的第13.8.2.18节引入了real32，real64和real128，其中这些默认整数标量命名常量的值应为类型类型参数的值，这些类型参数指定一个以位表示的存储大小为32、64的实数类型 ，和128。

可通过ISO_FORTRAN_ENV内部模块使用它们。

在撰写本书时，由于只有一个编译器支持整个Fortran 2008标准，因此在示例中将使用sp，dp和qp。

表5.10汇总了扩展类型的详细信息。

![图片](https://uploader.shimo.im/f/ElCdlqY91OSoHnVV.png!thumbnail)

可以看出，所有五个编译器都支持相同的32位和64位实数类型。 它们都支持扩展的128位类型，Cray，gfortran，Intel和Oracle相同，但是Nag不同。

这里是epsilon的详细信息，对于这些编译器而言，这是非常重要的。

EpsilonCray1.92592994438723585305597794258492732E-34gfortran1.92592994438723585305597794258492732E-0034Intel1.925929944387235853055977942584927E-0034Nag2.46519032881566189191165177E-32Oracle (Sun)1.9259299443872358530559779425849273E-34HugeCray1.18973149535723176508575932662800702E+4932gfortran1.18973149535723176508575932662800702E+4932Intel1.189731495357231765085759326628007E+4932Nag8.98846567431157953864652595E+307Oracle (Sun)1.189731495357231765085759326628007E+4932TinyCray3.3621031431120935062626778173217526E-4932gfortran3.36210314311209350626267781732175260E-4932Intel3.362103143112093506262677817321753E-4932Nag2.00416836000897277799610805E-292Oracle (Sun)3.3621031431120935062626778173217526E-4932在您可以使用编译器访问的任何系统上运行该程序，并将输出与以上示例进行比较。 大多数编译器将提供对32、64和128位实数的支持。

## 5.21 gfortran支持Intel扩展（80位）精度
如前所述，gfortran编译器还支持10字节实数。 这是Intel x86扩展精度格式。

x86扩展精度格式是一种80位格式，最早是在Intel 8087数学协处理器中实现的，并且所有基于x86设计并集成了浮点单元（FPU）的处理器均支持该格式。 这种80位格式将1位用于有效符号，将15位用于指数字段（即与128位四倍精度IEEE 754格式相同的范围），将64位用作有效位。

在后面的章节中，我们将看一个使用这种类型的例子。

## 5.22 示例11：计算中的文字实常数
我们已经看到了如何指定不同类型类型的整数和实数变量，但是我们还需要能够对文字常量执行相同的操作。 文字常量的示例为1.23、5.643E-2（默认实数）和400，-3（默认整数）。 要将文字常量声明为其他种类，您需要指定该常量，后跟一个下划线和kind类型参数。 下面是64位实际文字常量的两个示例：1.23_dp，5.643E-2_dp。

在使用不是默认类型的变量编写程序时，请务必小心，以确保所有文字常量也属于同一类型。 例如，如果您使用的是64位实数变量，那么请确保所有实数常量都为64位。 这是一个程序，其中变量和常量pi，area和r是32位实数，而pid，areaded和rd是64位实数。 尝试编译并运行程序。 您得到与我们相同的结果吗？

program ch0511implicit noneinteger, parameter :: dp = selected_real_kind( &15, 307)real, parameter :: pi = 3.1415926535897931real (dp), parameter :: pid = &3.1415926535897931_dpreal :: area, r = 2.0real (dp) :: aread, rd = 2.0_dparea = pi*r*raread = pid*rd*rdprint 100, r, rd100 format ('r = ', f22.18, /, 'rd = ', &f22.18)print 110, area, aread110 format ('area = ', f22.18, /, 'aread = ', &f22.18, /, 16x, ' ######')end program ch0511这是Nag编译器的输出。

C:\fortran\fortran_book_edition3\chapter5>ar = 2.000000000000000000rd = 2.000000000000000000area = 12.566370964050292969aread = 12.566370614359172464######现在编辑程序，并从分配给pid的文字常量中删除_dp。 您将看到area（32位实数）和aread（64位实数）的结果是相同的。 这是因为pid的文字常量会还原为默认的32位实数。

## C:\fortran\fortran_book_edition3\chapter5>ar = 2.000000000000000000rd = 2.000000000000000000area = 12.566370964050292969aread = 12.566370964050292969######5.23 求和与有限精度
下一个示例研究浮点数求和时出现的一些问题。在后面的章节中，我们将讨论更多的求和问题。

### 5.23.1 示例12：舍入问题
考虑下面的程序。

program ch0512implicit nonereal :: x1 = 1.0real :: x2 = 0.1integer iprint *, ’ x1 = ’, x1print *, ’ x2 = ’, x2do i = 1, 990x1 = x1 + x2end doprint *, ’ x1 = ’, x1end program ch0512这是英特尔编译器的输出。

x1 = 1.000000x2 = 0.1000000x1 = 99.99905这是Nag编译器的输出。

x1 = 1.0000000x2 = 0.1000000x1 = 99.9990463在两种情况下，由于舍入误差，总和是不精确的。

## 5.24 示例13：不同整数类型类型数字的二进制表示
对于那些希望了解各种整数的内部二进制表示形式的人，我们提供了以下程序

selected_int_kind（2）表示至少提供一个整数表示，其数字介于–10 ^ 2和+ 10 ^ 2之间。

selected_int_kind（4）表示至少提供一个整数表示，其数字介于–10 ^ 4和+ 10 ^ 4之间。

selected_int_kind（9）表示至少提供一个整数表示，其数字介于–10 ^ 9和+ 10 ^ 9之间。

我们使用int函数将一种整数表示形式转换为另一种整数表示形式。

我们使用逻辑函数btest来确定数字中该位置的二进制值是零还是一，即是否设置了该位。

i_in_bits是一个字符串，其中包含从整数的内部二进制形式到文本字符串的直接映射，该文本字符串显示为零或一的序列：

program ch0513!! use the bit functions in Fortran to write out! a! 32 bit integer number as a sequence of! zeros and ones!implicit noneinteger :: jinteger :: iinteger, parameter :: i8 = selected_int_kind(2 &)integer, parameter :: i16 = selected_int_kind( &4)integer, parameter :: i32 = selected_int_kind( &9)integer (i8) :: i1integer (i16) :: i2integer (i32) :: i3character (len=32) :: i_in_bitsprint *, ’ type in an integer ’read *, ii1 = int(i, kind(2))i2 = int(i, kind(4))i3 = int(i, kind(9))i_in_bits = ’ ’do j = 0, 7if (btest(i1,j)) theni_in_bits(8-j:8-j) = ’1’elsei_in_bits(8-j:8-j) = ’0’end ifend doprint *, ’ 1 2 3’print *, ’12345678901234567890123456789012’print *, i1print *, i_in_bitsdo j = 0, 15if (btest(i2,j)) theni_in_bits(16-j:16-j) = ’1’elsei_in_bits(16-j:16-j) = ’0’end ifend doprint *, i2print *, i_in_bitsdo j = 0, 31if (btest(i3,j)) theni_in_bits(32-j:32-j) = ’1’elsei_in_bits(32-j:32-j) = ’0’end ifend doprint *, i3print *, i_in_bitsend program ch0513do循环索引遵循从位0开始到位7的8位量的约定，从0开始到15结束的16位量等等。

所写出的数字遵循传统的数学符号，即在数字序列的右端具有最小有效数，即，十进制的127具有1 * 100、2 * 10和7 * 1，因此00100001为二进制 表示1 * 32 +1 * 1小数。

尝试在您使用的系统上运行该程序。 它会产生您期望的结果吗？ 尝试各种数字。 至少尝试以下0，+ 1，-1，-128、127、128，-32768、32767、32768。

## 5.25 示例14：实数的二进制表示
以下程序是上一个程序的简单变体，但是现在我们看一个浮点数：

program ch0514!! use the bit functions in Fortran to write out! a! 32 bit integer number equivalenced to a real! using the transfer intrinsic as a sequence of! zeros and ones!implicit noneinteger :: i, jcharacter (len=32) :: i_in_bits = ’ ’real :: x = 1.0print *, ’ 1 2 3’print *, ’12345678901234567890123456789012’print *, i_in_bitsi = transfer(x, i)do j = 0, 31if (btest(i,j)) theni_in_bits(32-j:32-j) = ’1’elsei_in_bits(32-j:32-j) = ’0’end ifend doprint *, xprint *, i_in_bitsend program ch0514我们在这里使用内在函数传递来提供帮助。 btest内部函数采用整数参数，因此我们需要将实数的位模式复制到整数变量中。

## 5.26 示例15：物理常数的初始化，版本1
这是使用早期表格中的物理常数数据初始化Fortran程序中的参数的三个示例中的第一个。

program ch0515implicit nonereal, parameter :: atomic_mass_constant = &1.660538921*10**(-27)real, parameter :: avogadro_constant = &6.02214129*10**23real, parameter :: boltzmann_constant = &1.3806488*10**(-23)real, parameter :: electron_mass = 9.10938291* &10**(-31)real, parameter :: elementary_charge = &1.602176565*10**(-19)real, parameter :: proton_mass = 1.672621777* &10**(-27)real, parameter :: speed_of_light_in_vacuum = &299792458real, parameter :: &newtonian_constant_of_gravitation = 6.67384* &10**(-11)print *, atomic_mass_constantprint *, avogadro_constantprint *, boltzmann_constantprint *, electron_massprint *, elementary_chargeprint *, proton_massprint *, speed_of_light_in_vacuumprint *, newtonian_constant_of_gravitationend program ch0515这是英特尔编译器的输出。

0.0000000E+001.2066952E+180.0000000E+000.0000000E+000.0000000E+000.0000000E+002.9979245E+080.0000000E+00这是Nag编译器的输出。

## nagfor ch0514.f90NAG Fortran CompilerError: ch0514.f90, line 6:Integer overflow for exponentiation 10**23Errors in declarations,no further processing for CH0514[NAG Fortran Compiler error termination, 1 error]5.27 示例16：初始化物理常数，版本2
这是使用早期表格中的物理常数数据初始化Fortran程序中的参数的三个示例中的第二个。

## program ch0516implicit nonereal, parameter :: atomic_mass_constant = &1.660538921e-27real, parameter :: avogadro_constant = &6.02214129e23real, parameter :: boltzmann_constant = &1.3806488e-23real, parameter :: electron_mass = &9.10938291e-31real, parameter :: elementary_charge = &1.602176565e-19real, parameter :: proton_mass = &1.672621777e-27real, parameter :: speed_of_light_in_vacuum = &299792458real, parameter :: &newtonian_constant_of_gravitation = &6.67384e-11print *, atomic_mass_constantprint *, avogadro_constantprint *, boltzmann_constantprint *, electron_massprint *, elementary_chargeprint *, proton_massprint *, speed_of_light_in_vacuumprint *, newtonian_constant_of_gravitationend program ch05165.28 示例17：物理常数的初始化，版本3
这是使用早期表格中的物理常数数据初始化Fortran程序中的参数的三个示例中的第三个。

## program ch0517implicit nonereal, parameter :: atomic_mass_constant = &1.660538921*10.0**(-27)real, parameter :: avogadro_constant = &6.02214129*10.0**23real, parameter :: boltzmann_constant = &1.3806488*10.0**(-23)real, parameter :: electron_mass = 9.10938291* &10.0**(-31)real, parameter :: elementary_charge = &1.602176565*10.0**(-19)real, parameter :: proton_mass = 1.672621777* &10.0**(-27)real, parameter :: speed_of_light_in_vacuum = &299792458real, parameter :: &newtonian_constant_of_gravitation = 6.67384* &10.0**(-11)print *, atomic_mass_constantprint *, avogadro_constantprint *, boltzmann_constantprint *, electron_massprint *, elementary_chargeprint *, proton_massprint *, speed_of_light_in_vacuumprint *, newtonian_constant_of_gravitationend program ch05175.29 如何选择适当种类类型的总结
要编写将在各种硬件上以类似方式进行算术运算的程序，需要了解以下内容：

* 整数数据表示模型，实际上是各种整数种类类型的字长。
* 实际数据表示模型，实际上是各种实际类型的字长以及尾数和指数中的位数。

有了这些信息，我们便可以选择一种类型，这种类型可以确保在从一个平台移动到另一个平台时确保最小的问题。

## 5.30 可变状态
Fortran对于变量的状态有两个概念：已定义和未定义。 如果程序没有为变量提供初始值（在类型语句中），则称其状态未定义。 考虑下面的代码段，该代码段来自较早的示例，该段计算了三个数字的总和：

real :: n1, n2, n3, average=0.0, total=0.0integer :: n = 3在上面的变量中，平均值，总数和n都有定义的状态。 但是，n1，n2和n3不确定。 未定义值的使用取决于实现，因此不可移植。 编写程序时必须小心，以确保变量尽可能具有已定义的状态。 我们将在随后的章节中再次关注这一领域。

## 5.31 Fortran和IEEE 754标准
ISO TR 15580向Fortran引入了IEEE算术支持。

IEEE 754-2008控制二进制浮点算法。 它指定数字格式，基本操作，转换和特殊条件。 2008年版取代了

* 754-1985

标准及相关

* IEEE 854-1987

概括了754-1985，涵盖了十进制算术和二进制。 第一个标准IEEE 754：1985涵盖了二进制浮点算法。 后来的IEEE 754：1987标准增加了十进制算法。

该标准的最新版本是ISO / IEC / IEEE 60559：2011。

现在有相当数量的硬件支持IEEE 754标准。

该标准可以从以下位置购买:

[http://www.iso.org/](http://www.iso.org/)

以下是有用的站点:

[http://grouper.ieee.org/groups/754/](http://grouper.ieee.org/groups/754/)

有很多很好的链接。

关于IEEE算术和Fortran的书中有单独的一章。

## 5.32 总结
以下是一些实用的规则和准则：

* 了解算术表达式求值的规则。
* 在必要时分解表达式，以确保按所需方式对表达式求值。
* 由于表达式中的整数除法，请小心截断。 请注意，这仅是除法的两个部分均为整数的问题。
* 当赋值语句的左侧有一个整数（即，将一个实数赋值给一个整数变量）时，请注意由于赋值语句而导致的截断。
* 如果要设置在整个程序中保持不变的常量，请使用parameter属性。
* 不要混淆精度和准确性。
* 了解使用的数值类型的默认类型是什么，最大和最小值和精度用于实数据，最大和最小用于整数数据。
* 已向您介绍了一些内部功能的用法。
# 第六章 一些基本原理
**目的**

本章的目的是介绍数组和do循环的基本概念，尤其是：

* 介绍数据表的概念以及用于描述数据表的一些正式术语：
  * 数组
  * 图库插图
  * 列表和线性列表
* 将数组讨论为随机访问结构，其中任何元素都可以像访问其他元素一样容易地访问，并注意数组中的数据都是同一类型。
* 介绍数据结构和相应控制结构的双重概念。
* 介绍Fortran中支持和操纵这些数据结构所必需的语句。
# 6.1 数据表
请思考以下示例。

### 6.1.1 电话簿
电话簿包含以下类型的条目：

![图片](https://uploader.shimo.im/f/h94KxoxtIH0w74cy.png!thumbnail)

可以通过多种方式考虑此结构，但也许最常见的是将其视为数据表，其中电话表中有三列，行的数量与条目的数量一样多。

现在考虑从该表中提取信息的方式。我们将扫描名称列以查找我们感兴趣的名称，然后沿着该行进行读取以查找地址或电话号码，即我们正在使用名称查找感兴趣的项目。

### 6.1.2 书籍目录
目录可以包含：

![图片](https://uploader.shimo.im/f/tBC07tNDkuzuDnpW.png!thumbnail)

同样，这可以看作是一个具有三列多行的数据表。我们将按照与电话号码簿相同的过程来提取信息。 我们将使用“作者”来查找可用的书籍。

### 6.1.3 考试分数及结果
包含：

![图片](https://uploader.shimo.im/f/6bzEhl94EWQpUYtD.png!thumbnail)

可以再次将其视为数据表。 本示例有七列五行。 我们将再次使用Name查找信息。

### 6.1.4 每月降雨量
以下数据是伦敦的每月平均降雨量（以英寸为单位）的样本：

![图片](https://uploader.shimo.im/f/ytSsJmuAgJRdvdlq.png!thumbnail)

在此表中有两列和十二行。 为了找出7月的降雨量，我们在Month列中扫描7月的表格，然后在同一行中找到7月的降雨量数字。

这些只是问题的许多示例中的一部分，其中所考虑的数据具有表格结构。 因此，大多数通用语言都有处理这种结构的机制。 这些结构的一些特殊名称包括：

* 线性列表
* 列表
* 向量
* 数组

在这里以及大多数有关Fortran编程的书中，最经常使用的术语是数组。

## 6.2 Fortran中的数组
这里需要考虑三个关键事项：

* 可以通过单个名称引用一组或一组项目的功能
* 引用单个项目或该组成员的能力，即查找它们
* 选择一种控制结构，使该集合或数组易于操作
### 6.2.1 维度属性
维属性将变量定义为数组。 这满足了能够通过单个名称引用一组项目的第一个要求。 以下是一些示例：

real , dimension(1:100) :: wagesinteger , dimension(1:10000) :: sample对于可变工资，它是实数类型，尺寸或大小为100，即可变数组工资最多可容纳100个实物。

对于变量样本，其类型为整数，并且数组的尺寸或大小为10,000，即变量样本最多可容纳10,000个整数项。

### 6.2.2 索引
索引使您可以引用或选择数组的各个元素。 在电话目录，书籍目录，考试成绩表和每月降雨量示例中，我们使用该名称来索引或查找感兴趣的项目。 我们将在每月降雨的示例中给出具体的Fortran代码。

### 6.2.3 控制结构
do语句通常用于操纵数组元素。 通常有几个语句由do语句控制，重复语句块通常称为do循环。 让我们看看突出以上内容的两个完整程序。

## 6.3 示例1：每月降雨
现在让我们更深入地研究这个较早的示例。 考虑以下：

![图片](https://uploader.shimo.im/f/gFdCHYwFgHBiK5Ib.png!thumbnail)

你们中的大多数人应该熟悉使用整数作为表示月份的替代方式的想法，例如，在2000年3月1日（英制）或1月3日（美化）中以1/3/2000表示的日期 样式）。 与其他编程语言一样，Fortran仅允许将整数用作数组的索引。 因此，当我们编写程序以使用数组时，我们必须将日常生活中使用的任何结构（作为我们的索引（电话目录，书籍目录和考试标记的示例中的名称））映射到Fortran中的整数表示形式。 以下是分配语句的示例，显示了索引的使用：

rainfall(1)=3.1前面我们看到，我们可以使用维度属性来指示变量是数组。 在上面的示例Fortran语句中，我们的数组称为降雨。 在此语句中，我们将值3.1分配给数组的第一个元素。 即一月的降雨量为3.1。 我们使用索引1表示第一个月。 考虑以下语句：

summeraverage = (rainfall(6) + rainfall(7) + rainfall(8))/3该陈述说，取6月，7月和8月的降雨量值，将其相加然后除以3，然后将结果分配给可变的夏季平均值，从而为我们提供三个夏季月份（北半球的降雨量）的平均值 课程！

以下程序从键盘读取12个月度值，计算当年的总和和平均值，然后打印出平均值。

program ch0601implicit nonereal :: total = 0.0, average = 0.0real, dimension (1:12) :: rainfallinteger :: monthprint *, ’ type in the rainfall values’print *, ’ one per line’do month = 1, 12read *, rainfall(month)end dodo month = 1, 12total = total + rainfall(month)end doaverage = total/12print *, ’ Average monthly rainfall was’print *, averageend program ch0601降雨是数组名称。 方括号中的变量月份是索引。 它的取值范围是1到12（含1和12），用于挑选或选择数组的元素。 因此，索引是一个变量，这允许在运行时动态操作数组。 do语句的一般形式是

do counter = start, end, increment

